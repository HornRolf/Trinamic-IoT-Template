{
  "libName": "tmc5161",
  "manufacturer": "Trinamic Motion Control",
  "description": "TMC5161 SPI interface",
  "version": "",
  "eelVersion": "3",
  "shoppingCarLinks": {},
  "requires": [
    "embedded",
    "gpio",
    "spi"
  ],
  "elements": [
    {
      "name": "TMC5161",
      "type": "EmbeddedTMC5161",
      "icon": "EmbeddedTouch.svg",
      "defaultAbility": "setVelocity",
      "defaultTrigger": "velocitySet",
      "hidden": false,
      "abilities": [
        {
          "name": "setup",
          "hidden": true,
          "triggers": [],
          "code": "ATMO_TMC5161_Config_t config;\r\n\r\nconfig.gpioDriverInstance = ATMO_PROPERTY(undefined, gpioDriverIntance);\r\nconfig.cs_pin = ATMO_PROPERTY(undefined, csPin);\r\nATMO_TMC5161_Init(&ATMO_VARIABLE(undefined, handle), &config);\r\n\r\nreturn ATMO_Status_Success;\r\n"
        },
        {
          "name": "setVelocity",
          "hidden": false,
          "triggers": [
            "velocitySet"
          ],
          "code": "int velocity;\r\n\r\nATMO_GetInt(in, &velocity);\r\nATMO_TMC5161_SetVelocity(ATMO_VARIABLE(undefined, handle), (uint8_t) velocity);\r\n\r\nreturn ATMO_Status_Success;\r\n"
        },
        {
          "name": "setAcceleration",
          "hidden": false,
          "triggers": [
            "accelerationSet"
          ],
          "code": "int acceleration;\r\n\r\nATMO_GetInt(in, &acceleration);\r\nATMO_TMC5161_SetAcceleration(ATMO_VARIABLE(undefined, handle), acceleration);\r\n\r\nreturn ATMO_Status_Success;\r\n"
        },
        {
          "name": "moveToPosition",
          "hidden": false,
          "triggers": [
            "movedToPosition"
          ],
          "code": "int position;\r\n\r\n// Extract arguments from input buffer\r\nATMO_GetInt(in, &position);\r\nATMO_TMC5161_MoveTo(ATMO_VARIABLE(undefined, handle), position);\r\n\r\nreturn ATMO_Status_Success;\r\n"
        },
        {
          "name": "setDirection",
          "hidden": false,
          "triggers": [
            "directionSet"
          ],
          "code": "ATMO_BOOL_t direction;\r\n\r\nATMO_GetBool(in, &direction);\r\n\r\nATMO_TMC5161_SetDirection(ATMO_VARIABLE(undefined, handle), direction);\r\n\r\nreturn ATMO_Status_Success;\r\n"
        },
        {
          "name": "stopMotor",
          "hidden": false,
          "triggers": [
            "motorStopped"
          ],
          "code": "ATMO_TMC5161_Stop(ATMO_VARIABLE(undefined, handle));\r\n\r\nreturn ATMO_Status_Success;\r\n"
        }
      ],
      "properties": [
        {
          "name": "gpioDriverIntance",
          "input": "driverInstance",
          "driverType": "gpio"
        },
        {
          "name": "csPin",
          "input": "number",
          "value": "P_CS"
        }
      ],
      "triggers": [],
      "variables": [
        {
          "name": "handle",
          "type": "ATMO_DriverInstanceHandle_t"
        }
      ],
      "language": {
        "en-US": {
          "EmbeddedTMC5161": "TMC5161",
          "setVelocity": "Set VMAX",
          "velocitySet": "VMAX set",
          "setAcceleration": "Set AMAX",
          "accelerationSet": "AMAX set",
          "moveToPosition": "Move motor to position X",
          "movedToPosition": "Motor Moved to Position X",
          "moveBy": "Move Motor by X Ticks",
          "setDirection": "Set Direction",
          "directionSet": "Direction set",
          "stopMotor": "Stop Motor",
          "motorStopped": "Motor stopped",
          "gpioDriverIntance": "GPIO Driver Instance",
          "csPin": "Chip Select Pin"
        }
      }
    }
  ],
  "files": {
    "common": {
      "headers": {
        "API_Header.h": "/*\n * tmc_header.h\n *\n *  Created on: 29.09.2016\n *      Author: ed\n */\n\n#ifndef TMC_API_HEADER_H_\n#define TMC_API_HEADER_H_\n\n\t#include \"Config.h\"\n\t#include \"Macros.h\"\n\t#include \"Constants.h\"\n\t#include \"Bits.h\"\n\t#include \"CRC.h\"\n\t#include \"RegisterAccess.h\"\n\t#include <stdlib.h>\n\t#include \"Types.h\"\n\n\t// TODO: Restructure these.\n\t/*\n\t * Goal: Just give these values here as status back to the IDE when used with EvalSystem.\n\t * Currently, this is obtained by just leaving out implementation specific error bits here.\n\t */\n\ttypedef enum {\n\t\tTMC_ERROR_NONE      = 0x00,\n\t\tTMC_ERROR_GENERIC   = 0x01,\n\t\tTMC_ERROR_FUNCTION  = 0x02,\n\t\tTMC_ERROR_MOTOR     = 0x08,\n\t\tTMC_ERROR_VALUE     = 0x10,\n\t\tTMC_ERROR_CHIP      = 0x40\n\t} TMCError;\n\n#endif /* TMC_API_HEADER_H_ */\n",
        "Bits.h": "// BIT DEFINITION\n#ifndef TMC_BITS_H_\n#define TMC_BITS_H_\n\n\t#define  BIT0   0x00000001\n\t#define  BIT1   0x00000002\n\t#define  BIT2   0x00000004\n\t#define  BIT3   0x00000008\n\t#define  BIT4   0x00000010\n\t#define  BIT5   0x00000020\n\t#define  BIT6   0x00000040\n\t#define  BIT7   0x00000080\n\t#define  BIT8   0x00000100\n\t#define  BIT9   0x00000200\n\t#define  BIT10  0x00000400\n\t#define  BIT11  0x00000800\n\t#define  BIT12  0x00001000\n\t#define  BIT13  0x00002000\n\t#define  BIT14  0x00004000\n\t#define  BIT15  0x00008000\n\t#define  BIT16  0x00010000\n\t#define  BIT17  0x00020000\n\t#define  BIT18  0x00040000\n\t#define  BIT19  0x00080000\n\t#define  BIT20  0x00100000\n\t#define  BIT21  0x00200000\n\t#define  BIT22  0x00400000\n\t#define  BIT23  0x00800000\n\t#define  BIT24  0x01000000\n\t#define  BIT25  0x02000000\n\t#define  BIT26  0x04000000\n\t#define  BIT27  0x08000000\n\t#define  BIT28  0x10000000\n\t#define  BIT29  0x20000000\n\t#define  BIT30  0x40000000\n\t#define  BIT31  0x80000000\n\n\t#define BYTE0_MASK   0x00000000000000FF\n\t#define BYTE0_SHIFT  0\n\t#define BYTE1_MASK   0x000000000000FF00\n\t#define BYTE1_SHIFT  8\n\t#define BYTE2_MASK   0x0000000000FF0000\n\t#define BYTE2_SHIFT  16\n\t#define BYTE3_MASK   0x00000000FF000000\n\t#define BYTE3_SHIFT  24\n\t#define BYTE4_MASK   0x000000FF00000000\n\t#define BYTE4_SHIFT  32\n\t#define BYTE5_MASK   0x0000FF0000000000\n\t#define BYTE5_SHIFT  40\n\t#define BYTE6_MASK   0x00FF000000000000\n\t#define BYTE6_SHIFT  48\n\t#define BYTE7_MASK   0xFF00000000000000\n\t#define BYTE7_SHIFT  56\n\n\t#define SHORT0_MASK   (BYTE0_MASK|BYTE1_MASK)\n\t#define SHORT0_SHIFT  BYTE0_SHIFT\n\t#define SHORT1_MASK   (BYTE2_MASK|BYTE3_MASK)\n\t#define SHORT1_SHIFT  BYTE2_SHIFT\n\t#define SHORT2_MASK   (BYTE4_MASK|BYTE5_MASK)\n\t#define SHORT2_SHIFT  BYTE4_SHIFT\n\t#define SHORT3_MASK   (BYTE6_MASK|BYTE7_MASK)\n\t#define SHORT3_SHIFT  BYTE6_SHIFT\n\n\t#define WORD0_MASK    (SHORT0_MASK|SHORT1_MASK)\n\t#define WORD0_SHIFT   SHORT0_SHIFT\n\t#define WORD1_MASK    (SHORT2_MASK|SHORT3_MASK)\n\t#define WORD1_SHIFT   SHORT2_SHIFT\n\n\t#define NIBBLE(value, n)  (((value) >> ((n) << 2)) & 0x0F)\n\t#define BYTE(value, n)    (((value) >> ((n) << 3)) & 0xFF)\n\t#define SHORT(value, n)   (((value) >> ((n) << 4)) & 0xFFFF)\n\t#define WORD(value, n)    (((value) >> ((n) << 5)) & 0xFFFFFFFF)\n\n\t#define _8_16(__1, __0)                                (((__1) << BYTE1_SHIFT) | ((__0) << BYTE0_SHIFT))\n\n\t#define _8_32(__3, __2, __1, __0)                      (((__3) << BYTE3_SHIFT) | ((__2) << BYTE2_SHIFT) | ((__1) << BYTE1_SHIFT) | ((__0) << BYTE0_SHIFT))\n\t#define _16_32(__1, __0)                               (((__1) << SHORT1_SHIFT) | ((__0) << SHORT0_SHIFT))\n\n\t#define _8_64(__7, __6, __5, __4, __3, __2, __1, __0)  (((__7) << BYTE7_SHIFT) | ((__6) << BYTE6_SHIFT) | ((__5) << BYTE5_SHIFT) | ((__4) << BYTE4_SHIFT) | ((__3) << BYTE3_SHIFT) | ((__2) << BYTE2_SHIFT) | ((__1) << BYTE1_SHIFT) | ((__0) << BYTE0_SHIFT))\n\t#define _16_64(__3, __2, __1, __0)                     (((__3) << SHORT3_SHIFT) | ((__2) << SHORT2_SHIFT) | ((__1) << SHORT1_SHIFT) | ((__0) << SHORT0_SHIFT))\n\t#define _32_64(__1, __0)                               (((__1) << WORD1_SHIFT) | ((__0) << WORD0_SHIFT))\n\n#endif /* TMC_BITS_H_ */\n",
        "CRC.h": "/*\n * CRC.h\n *\n *  Created on: 04.12.2017\n *      Author: LH\n */\n\n#ifndef TMC_HELPERS_CRC_H_\n#define TMC_HELPERS_CRC_H_\n\n\t#include \"Types.h\"\n\n\t// Amount of CRC tables available\n\t// Each table takes ~260 bytes (257 bytes, one bool and structure padding)\n\t#define CRC_TABLE_COUNT 2\n\n\tuint8_t tmc_fillCRC8Table(uint8_t polynomial, bool isReflected, uint8_t index);\n\tuint8_t tmc_CRC8(uint8_t *data, uint32_t bytes, uint8_t index);\n\n\tuint8_t tmc_tableGetPolynomial(uint8_t index);\n\tbool  tmc_tableIsReflected(uint8_t index);\n\n#endif /* TMC_HELPERS_CRC_H_ */\n",
        "Config.h": "/*\n * Config.h\n *\n *  Created on: 13.06.2018\n *      Author: LK\n */\n\n#ifndef TMC_HELPERS_CONFIG_H_\n#define TMC_HELPERS_CONFIG_H_\n\n#include \"Constants.h\"\n#include \"Types.h\"\n\n// Callback functions have IC-dependent parameters\n// To store the function pointers we use this dummy type, which is never\n// called without casting it to the IC-specific type first.\n// (Casting between function pointers is allowed by the C standard)\ntypedef void (*tmc_callback_config)(void);\n\n// States of a configuration\ntypedef enum {\n\tCONFIG_READY,\n\tCONFIG_RESET,\n\tCONFIG_RESTORE\n} ConfigState;\n\n// structure for configuration mechanism\ntypedef struct\n{\n\tConfigState          state;\n\tuint8_t                configIndex;\n\tint32_t                shadowRegister[TMC_REGISTER_COUNT];\n\tuint8_t (*reset)       (void);\n\tuint8_t (*restore)     (void);\n\ttmc_callback_config  callback;\n\tuint8_t                   channel;\n} ConfigurationTypeDef;\n\n#endif /* TMC_HELPERS_CONFIG_H_ */\n",
        "Constants.h": "/*\n * Constants.h\n *\n *  Created on: 16.05.2018\n *      Author: LK\n */\n\n#ifndef TMC_HELPERS_CONSTANTS_H_\n#define TMC_HELPERS_CONSTANTS_H_\n\n#define TMC_WRITE_BIT 0x80\n\n#define TMC_ADDRESS_MASK 0x7F\n\n#define TMC_DEFAULT_MOTOR 0\n\n//#define TMC_DIRECTION_RIGHT TRUE\n//#define TMC_DIRECTION_LEFT FALSE\n\n#define TMC_REGISTER_COUNT 128 // Default register count\n\n#endif /* TMC_HELPERS_CONSTANTS_H_ */\n",
        "Functions.h": "/*\n * Functions.h\n *\n *  Created on: 23.07.2018\n *      Author: ed\n */\n\n#ifndef TMC_FUNCTIONS_H_\n#define TMC_FUNCTIONS_H_\n\n\t#include \"API_Header.h\"\n\n\tint32_t tmc_limitInt(int32_t value, int32_t min, int32_t max);\n\tint64_t tmc_limitS64(int64_t value, int64_t min, int64_t max);\n\tint32_t tmc_sqrti(int32_t x);\n\tint32_t tmc_filterPT1(int64_t *akku, int32_t newValue, int32_t lastValue, uint8_t actualFilter, uint8_t maxFilter);\n\n#endif /* TMC_FUNCTIONS_H_ */\n",
        "LinearRamp1.h": "/*\n * LinearRamp1.h\n *\n *  Created on: 09.11.2018\n *      Author: LK\n */\n\n#ifndef TMC_RAMP_LINEARRAMP1_H_\n#define TMC_RAMP_LINEARRAMP1_H_\n\n#include \"API_Header.h\"\n#include \"Ramp.h\"\n\n// Position mode: When hitting the target position a velocity below the V_STOP threshold will be cut off to velocity 0\n#define TMC_RAMP_LINEAR_HOMING_DISTANCE 5\n\n// Position mode: When barely missing the target position by HOMING_DISTANCE or less, the remainder will be driven with V_STOP velocity\n#define TMC_RAMP_LINEAR_STOP_VELOCITY 5\n\n#define TMC_RAMP_LINEAR_ACCUMULATOR_VELOCITY_DECIMALS 17\n#define TMC_RAMP_LINEAR_ACCUMULATOR_POSITION_DECIMALS 17\n\ntypedef enum {\n\tTMC_RAMP_LINEAR_MODE_VELOCITY,\n\tTMC_RAMP_LINEAR_MODE_POSITION\n} TMC_LinearRamp_Mode;\n\ntypedef enum {\n\tTMC_RAMP_LINEAR_STATE_IDLE,\n\tTMC_RAMP_LINEAR_STATE_DRIVING,\n\tTMC_RAMP_LINEAR_STATE_BRAKING\n} TMC_LinearRamp_State;\n\ntypedef struct\n{\n\tuint32_t maxVelocity;\n\tint32_t targetPosition;\n\tint32_t rampPosition;\n\tint32_t targetVelocity;\n\tint32_t rampVelocity;\n\tint32_t acceleration;\n\tbool rampEnabled;\n\tint32_t accumulatorVelocity;\n\tint32_t accumulatorPosition;\n\tTMC_LinearRamp_Mode rampMode;\n\tint32_t dx;\n\tTMC_LinearRamp_State state;\n\tint32_t accelerationSteps;\n\tuint32_t homingDistance;\n\tuint32_t stopVelocity;\n} TMC_LinearRamp;\n\nvoid tmc_ramp_linear_init(TMC_LinearRamp *linearRamp);\nvoid tmc_ramp_linear_compute(TMC_LinearRamp *linearRamp, uint32_t delta);\nvoid tmc_ramp_linear_compute_velocity(TMC_LinearRamp *linearRamp, uint32_t delta);\nvoid tmc_ramp_linear_compute_position(TMC_LinearRamp *linearRamp, uint32_t delta);\n\nvoid tmc_ramp_linear_set_enabled(TMC_LinearRamp *linearRamp, bool enabled);\nvoid tmc_ramp_linear_set_maxVelocity(TMC_LinearRamp *linearRamp, uint32_t maxVelocity);\nvoid tmc_ramp_linear_set_targetPosition(TMC_LinearRamp *linearRamp, int32_t targetPosition);\nvoid tmc_ramp_linear_set_rampPosition(TMC_LinearRamp *linearRamp, int32_t rampPosition);\nvoid tmc_ramp_linear_set_targetVelocity(TMC_LinearRamp *linearRamp, int32_t targetVelocity);\nvoid tmc_ramp_linear_set_rampVelocity(TMC_LinearRamp *linearRamp, int32_t rampVelocity);\nvoid tmc_ramp_linear_set_acceleration(TMC_LinearRamp *linearRamp, int32_t acceleration);\nvoid tmc_ramp_linear_set_mode(TMC_LinearRamp *linearRamp, TMC_LinearRamp_Mode mode);\nvoid tmc_ramp_linear_set_homingDistance(TMC_LinearRamp *linearRamp, uint32_t homingDistance);\nvoid tmc_ramp_linear_set_stopVelocity(TMC_LinearRamp *linearRamp, uint32_t stopVelocity);\n\nbool tmc_ramp_linear_get_enabled(TMC_LinearRamp *linearRamp);\nuint32_t tmc_ramp_linear_get_maxVelocity(TMC_LinearRamp *linearRamp);\nint32_t tmc_ramp_linear_get_targetPosition(TMC_LinearRamp *linearRamp);\nint32_t tmc_ramp_linear_get_rampPosition(TMC_LinearRamp *linearRamp);\nint32_t tmc_ramp_linear_get_targetVelocity(TMC_LinearRamp *linearRamp);\nint32_t tmc_ramp_linear_get_rampVelocity(TMC_LinearRamp *linearRamp);\nint32_t tmc_ramp_linear_get_acceleration(TMC_LinearRamp *linearRamp);\nint32_t tmc_ramp_linear_get_dx(TMC_LinearRamp *linearRamp);\nTMC_LinearRamp_State tmc_ramp_linear_get_state(TMC_LinearRamp *linearRamp);\nTMC_LinearRamp_Mode tmc_ramp_linear_get_mode(TMC_LinearRamp *linearRamp);\nuint32_t tmc_ramp_linear_get_homingDistance(TMC_LinearRamp *linearRamp);\nuint32_t tmc_ramp_linear_get_stopVelocity(TMC_LinearRamp *linearRamp);\n\nvoid tmc_ramp_linear_reset_dx(TMC_LinearRamp *linearRamp);\n\n#endif /* TMC_RAMP_LINEARRAMP1_H_ */\n",
        "Macros.h": "/*\n * Macros.h\n *\n *  Created on: 04.01.2018\n *      Author: LH\n */\n\n#ifndef TMC_MACROS_H_\n#define TMC_MACROS_H_\n\n/* Cast a n bit signed int to a 32 bit signed int\n * This is done by checking the MSB of the signed int (Bit n).\n * If it is 1, the value is negative and the Bits 32 to n+1 are set to 1\n * If it is 0, the value remains unchanged\n */\n#define CAST_Sn_TO_S32(value, n) ((value) | (((value) & (1<<((n)-1)))? ~((0x1<<(n))-1) : 0 ))\n\n// Min/Max macros\n#ifndef MIN\n\t#define MIN(a,b) (((a)<(b)) ? (a) : (b))\n#endif\n#ifndef MAX\n\t#define MAX(a,b) (((a)>(b)) ? (a) : (b))\n#endif\n\n// Static Array length\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))\n\n// Generic mask/shift macros\n#define FIELD_GET(data, mask, shift) \\\n\t(((data) & (mask)) >> (shift))\n#define FIELD_SET(data, mask, shift, value) \\\n\t(((data) & (~(mask))) | (((value) << (shift)) & (mask)))\n\n// Register read/write/update macros using Mask/Shift:\n#define FIELD_READ(read, motor, address, mask, shift) \\\n\tFIELD_GET(read(motor, address), mask, shift)\n#define FIELD_WRITE(write, motor, address, mask, shift, value) \\\n\t(write(motor, address, ((value)<<(shift)) & (mask)))\n#define FIELD_UPDATE(read, write, motor, address, mask, shift, value) \\\n\t(write(motor, address, FIELD_SET(read(motor, address), mask, shift, value)))\n\n// Macro to surpress unused parameter warnings\n#ifndef UNUSED\n\t#define UNUSED(x) (void)(x)\n#endif\n\n// Memory access helpers\n// Force the compiler to access a location exactly once\n#define ACCESS_ONCE(x) *((volatile typeof(x) *) (&x))\n\n// Macro to remove write bit for shadow register array access\n#define TMC_ADDRESS(x) ((x) & (TMC_ADDRESS_MASK))\n\n#endif /* TMC_MACROS_H_ */\n",
        "Ramp.h": "/*\n * Ramp.h\n *\n *  Created on: 09.11.2018\n *      Author: LK\n */\n\n#ifndef TMC_RAMP_RAMP_H_\n#define TMC_RAMP_RAMP_H_\n\n#include \"LinearRamp1.h\"\n\ntypedef enum {\n\tTMC_RAMP_TYPE_LINEAR\n} TMC_RampType;\n\n// Initializes ramp parameters for given type\nvoid tmc_ramp_init(void *ramp, TMC_RampType type);\n\n// Computes new ramp state after delta ticks have passed\n// Note: To call this function periodically with a fixed delta-time, use delta = 1 and\n// define the units of acceleration as v/delta-time. If you want to specify a different unit,\n// change delta to your preference.\nvoid tmc_ramp_compute(void *ramp, TMC_RampType type, uint32_t delta);\n\n// Returns the current ramp velocity computed by the given ramp\nint32_t tmc_ramp_get_rampVelocity(void *ramp, TMC_RampType type);\n\n// Returns the current ramp position computed by the given ramp\nint32_t tmc_ramp_get_rampPosition(void *ramp, TMC_RampType type);\n\n// Enable/disable ramps\nbool tmc_ramp_get_enabled(void *ramp, TMC_RampType type);\nvoid tmc_ramp_set_enabled(void *ramp, TMC_RampType type, bool enabled);\nvoid tmc_ramp_toggle_enabled(void *ramp, TMC_RampType type);\n\n// Get the position change for last delta time frame\nint32_t tmc_ramp_get_dx(void *ramp, TMC_RampType type);\n\n// Resets dx value between computing deltas\nvoid tmc_ramp_reset_dx(void *ramp, TMC_RampType type);\n\n#endif /* TMC_RAMP_RAMP_H_ */\n",
        "RegisterAccess.h": "/*\n * RegisterAccess.h\n *\n *  Created on: 12.07.2017\n *      Author: LK\n *\n *  The permission system aims to allow a general-purpose implementation for\n *  all common hardware register usages. This includes:\n *  - Trivial Cases: Read, Write, Read & Write\n *\n *  - Read & Write accesses that route to different values/functions of a chip.\n *    (e.g. serial communication, where read/write corresponds to RX/TX)\n *  - Read to clear, write to clear. This does not directly affect the access,\n *    but can be used to implement a software shadow register for flags\n *    (ORing the read value into a shadow register instead of overwriting).\n *  - Registers with default values that are not known (e.g. Factory configuration\n *    values that should not be overwritten by default).\n */\n\n#ifndef TMC_HELPERS_REGISTERACCESS_H\n#define TMC_HELPERS_REGISTERACCESS_H\n\n// Register access bits\n/* Lower nibble is used for read/write, higher nibble is used for\n * special case registers. This makes it easy to identify the read/write\n * part of the permissions in a hexadecimal permission number.\n * The dirty bit will only ever be set at runtime, so we keep the easily\n * readable lower nibble.\n */\n#define TMC_ACCESS_NONE        0x00\n\n#define TMC_ACCESS_READ        0x01\n#define TMC_ACCESS_WRITE       0x02\n                            // 0x04 is currently unused\n#define TMC_ACCESS_DIRTY       0x08  // Register has been written since reset -> shadow register is valid for restore\n\n// Special Register bits\n#define TMC_ACCESS_RW_SPECIAL  0x10  // Read and write are independent - different values and/or different functions\n#define TMC_ACCESS_FLAGS       0x20  // Register has read or write to clear flags.\n#define TMC_ACCESS_HW_PRESET   0x40  // Register has hardware presets (e.g. Factory calibrations) - do not write a default value\n                            // 0x80 is currently unused\n\n// Permission combinations\n#define TMC_ACCESS_RW              (TMC_ACCESS_READ  | TMC_ACCESS_WRITE)        // 0x03 - Read and write\n#define TMC_ACCESS_RW_SEPARATE     (TMC_ACCESS_RW    | TMC_ACCESS_RW_SPECIAL)   // 0x13 - Read and write, with separate values/functions\n#define TMC_ACCESS_R_FLAGS         (TMC_ACCESS_READ  | TMC_ACCESS_FLAGS)        // 0x21 - Read, has flags (read to clear)\n#define TMC_ACCESS_RW_FLAGS        (TMC_ACCESS_RW    | TMC_ACCESS_FLAGS)        // 0x23 - Read and write, has flags (read or write to clear)\n#define TMC_ACCESS_W_PRESET        (TMC_ACCESS_WRITE | TMC_ACCESS_HW_PRESET)    // 0x42 - Write, has hardware preset - skipped in reset routine\n#define TMC_ACCESS_RW_PRESET       (TMC_ACCESS_RW    | TMC_ACCESS_HW_PRESET)    // 0x43 - Read and write, has hardware presets - skipped in reset routine\n\n// Helper macros\n#define TMC_IS_READABLE(x)    ((x) & TMC_ACCESS_READ)\n#define TMC_IS_WRITABLE(x)    ((x) & TMC_ACCESS_WRITE)\n#define TMC_IS_DIRTY(x)       ((x) & TMC_ACCESS_DIRTY)\n#define TMC_IS_RESETTABLE(x)  (((x) & (TMC_ACCESS_W_PRESET)) == TMC_ACCESS_WRITE) // Write bit set, Hardware preset bit not set\n#define TMC_IS_RESTORABLE(x)  (((x) & TMC_ACCESS_WRITE) && (!(x & TMC_ACCESS_HW_PRESET) || (x & TMC_ACCESS_DIRTY))) // Write bit set, if it's a hardware preset register, it needs to be dirty\n\n// Struct for listing registers that have constant contents which we cannot\n// obtain by reading them due to the register not being read-back.\ntypedef struct\n{\n\tuint8_t address;\n\tint32_t value;\n} TMCRegisterConstant;\n\n// Helper define:\n// Most register permission arrays are initialized with 128 values.\n// In those fields its quite hard to have an easy overview of available\n// registers. For that, ____ is defined to 0, since 4 underscores are\n// very easy to distinguish from the 2-digit hexadecimal values.\n// This way, the used registers (permission != ACCESS_NONE) are easily spotted\n// amongst unused (permission == ACCESS_NONE) registers.\n#define ____ 0x00\n\n// Helper define:\n// Default reset values are not used if the corresponding register has a\n// hardware preset. Since this is not directly visible in the default\n// register reset values array, N_A is used as an indicator for a preset\n// value, where any value will be ignored anyways (N_A: not available).\n#define N_A 0\n\n#endif /* TMC_HELPERS_REGISTERACCESS_H */\n",
        "TMC5161.h": "/*\n * TMC5161.h\n *\n *  Created on: 13.06.2018\n *      Author: LK\n */\n\n#ifndef TMC_IC_TMC5161_H_\n#define TMC_IC_TMC5161_H_\n\n#include \"Constants.h\"\n#include \"API_Header.h\"\n#include \"TMC5161_Register.h\"\n#include \"TMC5161_Constants.h\"\n#include \"TMC5161_Fields.h\"\n\n// Helper macros\n#define TMC5161_FIELD_READ(tdef, address, mask, shift) \\\n\tFIELD_GET(tmc5161_readInt(tdef, address), mask, shift)\n#define TMC5161_FIELD_UPDATE(tdef, address, mask, shift, value) \\\n\t(tmc5161_writeInt(tdef, address, FIELD_SET(tmc5161_readInt(tdef, address), mask, shift, value)))\n\n// Factor between 10ms units and internal units for 16MHz\n//#define TPOWERDOWN_FACTOR (4.17792*100.0/255.0)\n// TPOWERDOWN_FACTOR = k * 100 / 255 where k = 2^18 * 255 / fClk for fClk = 16000000)\n\n// Register access permissions:\n//   0x00: none (reserved)\n//   0x01: read\n//   0x02: write\n//   0x03: read/write\n//   0x13: read/write, seperate functions/values for reading or writing\n//   0x21: read, flag register (read to clear)\n//   0x42: write, has hardware presets on reset\nstatic const uint8_t tmc5161_defaultRegisterAccess[TMC5161_REGISTER_COUNT] =\n{\n//  0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F\n\t0x03, 0x13, 0x01, 0x02, 0x13, 0x02, 0x02, 0x01, 0x01, 0x02, 0x02, 0x02, 0x01, ____, ____, ____, // 0x00 - 0x0F\n\t0x02, 0x02, 0x01, 0x02, 0x02, 0x02, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, // 0x10 - 0x1F\n\t0x03, 0x03, 0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, ____, 0x02, 0x02, 0x02, 0x03, ____, ____, // 0x20 - 0x2F\n\t____, ____, ____, 0x02, 0x03, 0x13, 0x01, ____, 0x03, 0x03, 0x02, 0x13, 0x01, 0x02, ____, ____, // 0x30 - 0x3F\n\t____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, // 0x40 - 0x4F\n\t____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, // 0x50 - 0x5F\n\t0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x01, 0x01, 0x03, 0x02, 0x02, 0x01, // 0x60 - 0x6F\n\t0x42, 0x01, 0x01, 0x01, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____, ____  // 0x70 - 0x7F\n};\n\n// todo ADD API 3: Some Registers have default hardware configuration from OTP, we shouldnt overwrite those - add the weak write register permission and use it here (LH)\n// Default Register Values\n#define R00 0x00000008  // GCONF\n#define R09 0x00010C0C  // SHORT_CONF\n#define R0A 0x00080200  // DRV_CONF\n#define R10 0x00070A03  // IHOLD_IRUN\n#define R11 0x0000000A  // TPOWERDOWN\n#define R2B 0x00000001  // VSTOP\n#define R3A 0x00010000  // ENC_CONST\n#define R6C 0x00410153  // CHOPCONF\n#define R70 0xC40C001E  // PWMCONF\n\nstatic const int32_t tmc5161_defaultRegisterResetState[TMC5161_REGISTER_COUNT] =\n{\n//\t0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F\n\tR00, 0,   0,   0,   0,   0,   0,   0,   0,   R09, R0A, 0,   0,   0,   0,   0, // 0x00 - 0x0F\n\tR10, R11, 0,   0,   0,   0,   0,   0,   0,   0,   0,   R2B, 0,   0,   0,   0, // 0x10 - 0x1F\n\t0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, // 0x20 - 0x2F\n\t0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   R3A, 0,   0,   0,   0,   0, // 0x30 - 0x3F\n\t0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, // 0x40 - 0x4F\n\t0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0, // 0x50 - 0x5F\n\tN_A, N_A, N_A, N_A, N_A, N_A, N_A, N_A, N_A, N_A, 0,   0,   R6C, 0,   0,   0, // 0x60 - 0x6F\n\tR70, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0  // 0x70 - 0x7F\n};\n\n#undef R00\n#undef R09\n#undef R0A\n#undef R10\n#undef R11\n#undef R2B\n#undef R3A\n#undef R6C\n#undef R70\n\ntypedef struct\n{\n\tConfigurationTypeDef *config;\n\tint velocity, oldX;\n\tuint32_t oldTick;\n\tint32_t registerResetState[TMC5161_REGISTER_COUNT];\n\tuint8_t registerAccess[TMC5161_REGISTER_COUNT];\n} TMC5161TypeDef;\n\ntypedef void (*tmc5161_callback)(TMC5161TypeDef*, ConfigState);\n\nvoid tmc5161_writeDatagram(uint8_t channel, uint8_t address, uint8_t x1, uint8_t x2, uint8_t x3, uint8_t x4);\nvoid tmc5161_writeInt(uint8_t channel, uint8_t address, int32_t value);\nint32_t tmc5161_readInt(uint8_t channel, uint8_t address);\n\nvoid tmc5161_init(void);\n\nvoid tmc5161_rotate(uint8_t channel, int32_t velocity);\nvoid tmc5161_right(uint8_t channel, uint32_t velocity);\nvoid tmc5161_left(uint8_t channel, uint32_t velocity);\nvoid tmc5161_stop(uint8_t channel);\nvoid tmc5161_moveTo(uint8_t channel, int32_t position, uint32_t velocity);\nvoid tmc5161_moveBy(uint8_t channel, int32_t ticks, uint32_t velocity);\n\n#endif /* TMC_IC_TMC5161_H_ */\n",
        "TMC5161_Constants.h": "/*\n * TMC5161_Constants.h\n *\n *  Created on: 13.06.2018\n *      Author: LK\n */\n\n#ifndef TMC_IC_TMC5161_TMC5161_CONSTANTS_H_\n#define TMC_IC_TMC5161_TMC5161_CONSTANTS_H_\n\n#include \"Constants.h\"\n\n#define TMC5161_REGISTER_COUNT   TMC_REGISTER_COUNT\n#define TMC5161_MOTORS           1\n#define TMC5161_WRITE_BIT        TMC_WRITE_BIT\n#define TMC5161_ADDRESS_MASK     TMC_ADDRESS_MASK\n#define TMC5161_MAX_VELOCITY     8388096\n#define TMC5161_MAX_ACCELERATION u16_MAX\n\n// ramp modes (Register TMC5161_RAMPMODE)\n#define TMC5161_MODE_POSITION  0\n#define TMC5161_MODE_VELPOS    1\n#define TMC5161_MODE_VELNEG    2\n#define TMC5161_MODE_HOLD      3\n\n// limit switch mode bits (Register TMC5161_SWMODE)\n#define TMC5161_SW_STOPL_ENABLE    0x0001\n#define TMC5161_SW_STOPR_ENABLE    0x0002\n#define TMC5161_SW STOPL_POLARITY  0x0004\n#define TMC5161_SW_STOPR_POLARITY  0x0008\n#define TMC5161_SW_SWAP_LR         0x0010\n#define TMC5161_SW_LATCH_L_ACT     0x0020\n#define TMC5161_SW_LATCH_L_INACT   0x0040\n#define TMC5161_SW_LATCH_R_ACT     0x0080\n#define TMC5161_SW_LATCH_R_INACT   0x0100\n#define TMC5161_SW_LATCH_ENC       0x0200\n#define TMC5161_SW_SG_STOP         0x0400\n#define TMC5161_SW_SOFTSTOP        0x0800\n\n// Status bits (Register TMC5161_RAMPSTAT)\n#define TMC5161_RS_STOPL          0x0001\n#define TMC5161_RS_STOPR          0x0002\n#define TMC5161_RS_LATCHL         0x0004\n#define TMC5161_RS_LATCHR         0x0008\n#define TMC5161_RS_EV_STOPL       0x0010\n#define TMC5161_RS_EV_STOPR       0x0020\n#define TMC5161_RS_EV_STOP_SG     0x0040\n#define TMC5161_RS_EV_POSREACHED  0x0080\n#define TMC5161_RS_VELREACHED     0x0100\n#define TMC5161_RS_POSREACHED     0x0200\n#define TMC5161_RS_VZERO          0x0400\n#define TMC5161_RS_ZEROWAIT       0x0800\n#define TMC5161_RS_SECONDMOVE     0x1000\n#define TMC5161_RS_SG             0x2000\n\n// Encoderbits (Register TMC5161_ENCMODE)\n#define TMC5161_EM_DECIMAL     0x0400\n#define TMC5161_EM_LATCH_XACT  0x0200\n#define TMC5161_EM_CLR_XENC    0x0100\n#define TMC5161_EM_NEG_EDGE    0x0080\n#define TMC5161_EM_POS_EDGE    0x0040\n#define TMC5161_EM_CLR_ONCE    0x0020\n#define TMC5161_EM_CLR_CONT    0x0010\n#define TMC5161_EM_IGNORE_AB   0x0008\n#define TMC5161_EM_POL_N       0x0004\n#define TMC5161_EM_POL_B       0x0002\n#define TMC5161_EM_POL_A       0x0001\n\n#endif /* TMC_IC_TMC5161_TMC5161_CONSTANTS_H_ */\n",
        "TMC5161_Fields.h": "/*\n*  TMC5161_Fields.h\n*  Author: LK\n*  Generated by MaskShiftConverter (unchecked)\n*/\n\n#ifndef TMC5161_FIELDS_H\n#define TMC5161_FIELDS_H\n\n#define TMC5161_RECALIBRATE_MASK                      0x01 // GCONF //\n#define TMC5161_RECALIBRATE_SHIFT                     0 // min.: 0, max.: 1, default: 0\n#define TMC5161_FASTSTANDSTILL_MASK                   0x02 // GCONF // Timeout for step execution until standstill detection\n#define TMC5161_FASTSTANDSTILL_SHIFT                  1 // min.: 0, max.: 1, default: 0\n#define TMC5161_EN_PWM_MODE_MASK                      0x04 // GCONF //\n#define TMC5161_EN_PWM_MODE_SHIFT                     2 // min.: 0, max.: 1, default: 0\n#define TMC5161_MULTISTEP_FILT_MASK                   0x08 // GCONF //\n#define TMC5161_MULTISTEP_FILT_SHIFT                  3 // min.: 0, max.: 1, default: 0\n#define TMC5161_SHAFT_MASK                            0x10 // GCONF //\n#define TMC5161_SHAFT_SHIFT                           4 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG0_ERROR_ONLY_WITH_SD_MODE1_MASK   0x20 // GCONF //\n#define TMC5161_DIAG0_ERROR_ONLY_WITH_SD_MODE1_SHIFT  5 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG0_OTPW_ONLY_WITH_SD_MODE1_MASK    0x40 // GCONF //\n#define TMC5161_DIAG0_OTPW_ONLY_WITH_SD_MODE1_SHIFT   6 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG0_STALL_MASK                      0x80 // GCONF //\n#define TMC5161_DIAG0_STALL_SHIFT                     7 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG1_STALL_MASK                      0x0100 // GCONF //\n#define TMC5161_DIAG1_STALL_SHIFT                     8 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG1_INDEX_MASK                      0x0200 // GCONF //\n#define TMC5161_DIAG1_INDEX_SHIFT                     9 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG1_ONSTATE_MASK                    0x0400 // GCONF //\n#define TMC5161_DIAG1_ONSTATE_SHIFT                   10 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG1_STEPS_SKIPPED_MASK              0x0800 // GCONF //\n#define TMC5161_DIAG1_STEPS_SKIPPED_SHIFT             11 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG0_INT_PUSHPULL_MASK               0x1000 // GCONF //\n#define TMC5161_DIAG0_INT_PUSHPULL_SHIFT              12 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG1_POSCOMP_PUSHPULL_MASK           0x2000 // GCONF //\n#define TMC5161_DIAG1_POSCOMP_PUSHPULL_SHIFT          13 // min.: 0, max.: 1, default: 0\n#define TMC5161_SMALL_HYSTERESIS_MASK                 0x4000 // GCONF //\n#define TMC5161_SMALL_HYSTERESIS_SHIFT                14 // min.: 0, max.: 1, default: 0\n#define TMC5161_STOP_ENABLE_MASK                      0x8000 // GCONF //\n#define TMC5161_STOP_ENABLE_SHIFT                     15 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIRECT_MODE_MASK                      0x010000 // GCONF //\n#define TMC5161_DIRECT_MODE_SHIFT                     16 // min.: 0, max.: 1, default: 0\n#define TMC5161_TEST_MODE_MASK                        0x020000 // GCONF //\n#define TMC5161_TEST_MODE_SHIFT                       17 // min.: 0, max.: 1, default: 0\n#define TMC5161_RECALIBRATE_MASK                      0x01 // GCONF //\n#define TMC5161_RECALIBRATE_SHIFT                     0 // min.: 0, max.: 1, default: 0\n#define TMC5161_FASTSTANDSTILL_MASK                   0x02 // GCONF // Timeout for step execution until standstill detection\n#define TMC5161_FASTSTANDSTILL_SHIFT                  1 // min.: 0, max.: 1, default: 0\n#define TMC5161_EN_PWM_MODE_MASK                      0x04 // GCONF //\n#define TMC5161_EN_PWM_MODE_SHIFT                     2 // min.: 0, max.: 1, default: 0\n#define TMC5161_MULTISTEP_FILT_MASK                   0x08 // GCONF //\n#define TMC5161_MULTISTEP_FILT_SHIFT                  3 // min.: 0, max.: 1, default: 0\n#define TMC5161_SHAFT_MASK                            0x10 // GCONF //\n#define TMC5161_SHAFT_SHIFT                           4 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG0_STEP_MASK                       0x80 // GCONF //\n#define TMC5161_DIAG0_STEP_SHIFT                      7 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG1_DIR_MASK                        0x0100 // GCONF //\n#define TMC5161_DIAG1_DIR_SHIFT                       8 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG0_INT_PUSHPULL_MASK               0x1000 // GCONF //\n#define TMC5161_DIAG0_INT_PUSHPULL_SHIFT              12 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIAG1_POSCOMP_PUSHPULL_MASK           0x2000 // GCONF //\n#define TMC5161_DIAG1_POSCOMP_PUSHPULL_SHIFT          13 // min.: 0, max.: 1, default: 0\n#define TMC5161_SMALL_HYSTERESIS_MASK                 0x4000 // GCONF //\n#define TMC5161_SMALL_HYSTERESIS_SHIFT                14 // min.: 0, max.: 1, default: 0\n#define TMC5161_STOP_ENABLE_MASK                      0x8000 // GCONF //\n#define TMC5161_STOP_ENABLE_SHIFT                     15 // min.: 0, max.: 1, default: 0\n#define TMC5161_DIRECT_MODE_MASK                      0x010000 // GCONF //\n#define TMC5161_DIRECT_MODE_SHIFT                     16 // min.: 0, max.: 1, default: 0\n#define TMC5161_TEST_MODE_MASK                        0x020000 // GCONF //\n#define TMC5161_TEST_MODE_SHIFT                       17 // min.: 0, max.: 1, default: 0\n#define TMC5161_RESET_MASK                            0x01 // GSTAT // reset\n#define TMC5161_RESET_SHIFT                           0 // min.: 0, max.: 1, default: 0\n#define TMC5161_DRV_ERR_MASK                          0x02 // GSTAT // drv_err\n#define TMC5161_DRV_ERR_SHIFT                         1 // min.: 0, max.: 1, default: 0\n#define TMC5161_UV_CP_MASK                            0x04 // GSTAT // uv_cp\n#define TMC5161_UV_CP_SHIFT                           2 // min.: 0, max.: 1, default: 0\n#define TMC5161_IFCNT_MASK                            0xFF // IFCNT // Interface transmission counter. This register becomes incremented with each successful UART interface write access. Read out to check the serial transmission for lost data. Read accesses do not change the content. The counter wraps around from 255 to 0.\n#define TMC5161_IFCNT_SHIFT                           0 // min.: 0, max.: 255, default: 0\n#define TMC5161_SLAVEADDR_MASK                        0xFF // SLAVECONF // These eight bits set the address of unit for the UART interface. The address becomes incremented by one when the external address pin NEXTADDR is active. Range: 0-253 (254 cannot be incremented)\n#define TMC5161_SLAVEADDR_SHIFT                       0 // min.: 0, max.: 255, default: 0\n#define TMC5161_SENDDELAY_MASK                        0x0F00 // SLAVECONF // SENDDELAY for read access (time until reply is sent): 0, 1:  8 bit times 2, 3:  3*8 bit times 4, 5:  5*8 bit times 6, 7:  7*8 bit times 8, 9:  9*8 bit times 10, 11: 11*8 bit times 12, 13: 13*8 bit times 14, 15: 15*8 bit times\n#define TMC5161_SENDDELAY_SHIFT                       8 // min.: 0, max.: 15, default: 0\n#define TMC5161_REFL_STEP_MASK                        0x01 // IOIN / OUTPUT // REFL_STEP\n#define TMC5161_REFL_STEP_SHIFT                       0 // min.: 0, max.: 1, default: 0\n#define TMC5161_REFR_DIR_MASK                         0x02 // IOIN / OUTPUT // REFR_DIR\n#define TMC5161_REFR_DIR_SHIFT                        1 // min.: 0, max.: 1, default: 0\n#define TMC5161_ENCB_DCEN_CFG4_MASK                   0x04 // IOIN / OUTPUT // ENCB_DCEN_CFG4\n#define TMC5161_ENCB_DCEN_CFG4_SHIFT                  2 // min.: 0, max.: 1, default: 0\n#define TMC5161_ENCA_DCIN_CFG5_MASK                   0x08 // IOIN / OUTPUT // ENCA_DCIN_CFG5\n#define TMC5161_ENCA_DCIN_CFG5_SHIFT                  3 // min.: 0, max.: 1, default: 0\n#define TMC5161_DRV_ENN_CFG6_MASK                     0x10 // IOIN / OUTPUT // DRV_ENN_CFG6\n#define TMC5161_DRV_ENN_CFG6_SHIFT                    4 // min.: 0, max.: 1, default: 0\n#define TMC5161_ENC_N_DCO_MASK                        0x20 // IOIN / OUTPUT // ENC_N_DCO\n#define TMC5161_ENC_N_DCO_SHIFT                       5 // min.: 0, max.: 1, default: 0\n#define TMC5161_SD_MODE_MASK                          0x40 // IOIN / OUTPUT // SD_MODE\n#define TMC5161_SD_MODE_SHIFT                         6 // min.: 0, max.: 1, default: 0\n#define TMC5161_SWCOMP_IN_MASK                        0x80 // IOIN / OUTPUT // Shows voltage difference of SWN and SWP. Bring DIAG outputs to high level with pushpull disabled to test the comparator.\n#define TMC5161_SWCOMP_IN_SHIFT                       7 // min.: 0, max.: 1, default: 0\n#define TMC5161_VERSION_MASK                          0xFF000000 // IOIN / OUTPUT // VERSION: 0x11=first version of the IC; Identical numbers mean full digital compatibility.\n#define TMC5161_VERSION_SHIFT                         24 // min.: 0, max.: 255, default: 0\n#define TMC5161_OUTPUT_PIN_POLARITY_MASK              0x01 // IOIN / OUTPUT // Output polarity of SDO_CFG0 pin in UART mode. Its main purpose it to use SDO_CFG0 as NAO next address output signal for chain addressing of multiple ICs. Attention: Reset Value is 1 for use as NAO to next IC in single wire chain\n#define TMC5161_OUTPUT_PIN_POLARITY_SHIFT             0 // min.: 0, max.: 1, default: 0\n#define TMC5161_X_COMPARE_MASK                        0xFFFFFFFF // X_COMPARE // Position comparison register for motion controller position strobe. The Position pulse is available on output SWP_DIAG1.\n#define TMC5161_X_COMPARE_SHIFT                       0 // min.: 0, max.: 4294967295, default: 0\n#define TMC5161_OTPBIT_MASK                           0x07 // OTP_PROG // Selection of OTP bit to be programmed to the selected byte location (n=0..7: programs bit n to a logic 1)\n#define TMC5161_OTPBIT_SHIFT                          0 // min.: 0, max.: 7, default: 0\n#define TMC5161_OTPBYTE_MASK                          0x30 // OTP_PROG // Set to 00\n#define TMC5161_OTPBYTE_SHIFT                         4 // min.: 0, max.: 0, default: 0\n#define TMC5161_OTPMAGIC_MASK                         0xFF00 // OTP_PROG // Set  to  0xBD  to  enable  programming.  A  programming time of  minimum 10ms per bit is  recommended (check by reading OTP_READ).\n#define TMC5161_OTPMAGIC_SHIFT                        8 // min.: 0, max.: 255, default: 0\n#define TMC5161_OTP_TBL_MASK                          0x80 // OTP_READ // Reset default for TBL\n#define TMC5161_OTP_TBL_SHIFT                         7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OTP_BBM_MASK                          0x40 // OTP_READ // Reset default for BBM\n#define TMC5161_OTP_BBM_SHIFT                         6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OTP_S2_LEVEL_MASK                     0x20 // OTP_READ // Reset default for Short detection Levels\n#define TMC5161_OTP_S2_LEVEL_SHIFT                    5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OTP_FCLKTRIM_MASK                     0x1F // OTP_READ // Reset default for FCLKTRIM 0: lowest frequency setting 31: highest frequency setting Attention: This value is pre-programmed by factory clock trimming to the default clock frequency of 12MHz and differs between individual ICs! It should not be altered.\n#define TMC5161_OTP_FCLKTRIM_SHIFT                    0 // min.: 0, max.: 31, default: 0\n#define TMC5161_FCLKTRIM_MASK                         0x1F // FACTORY_CONF // FCLKTRIM (Reset default: OTP)           0-31:  Lowest  to  highest  clock  frequency.  Check  at charge  pump  output.  The  frequency  span  is  not guaranteed,  but  it  is  tested,  that  tuning  to  12MHz internal  clock  is  possible.  The  devices  come  preset  to 12MHz clock frequency by OTP programming.\n#define TMC5161_FCLKTRIM_SHIFT                        0 // min.: 0, max.: 31, default: 0\n#define TMC5161_S2VS_LEVEL_MASK                       0x0F // SHORT_CONF // Short to VS detector level (15= lowest sensitivity) (Reset Default: OTP 6 or 12)\n#define TMC5161_S2VS_LEVEL_SHIFT                      0 // min.: 0, max.: 15, default: 0\n#define TMC5161_S2GND_LEVEL_MASK                      0x0F00 // SHORT_CONF // Short to GND detector level (15= lowest sensitivity) (Reset Default: OTP 6 or 12)\n#define TMC5161_S2GND_LEVEL_SHIFT                     8 // min.: 0, max.: 15, default: 0\n#define TMC5161_SHORTFILTER_MASK                      0x030000 // SHORT_CONF // Spike filtering bandwidth for short detection (0=lowest) (Reset Default = %01)\n#define TMC5161_SHORTFILTER_SHIFT                     16 // min.: 0, max.: 3, default: 0\n#define TMC5161_SHORTDELAY_MASK                       0x040000 // SHORT_CONF // Detector delay (0=750ns, 1=1500ns) (Reset Default = 0)\n#define TMC5161_SHORTDELAY_SHIFT                      18 // min.: 0, max.: 1, default: 0\n#define TMC5161_BBMTIME_MASK                          0x1F // DRV_CONF // Analog Break-Before make timer (0=shortest, 31=longest) (Reset Default = 0)\n#define TMC5161_BBMTIME_SHIFT                         0 // min.: 0, max.: 31, default: 0\n#define TMC5161_BBMCLKS_MASK                          0x0F00 // DRV_CONF // Digital BBM time in multiple of 1 clock. The longer setting rules (BBMTIME vs. BBMCLKS). (Reset Default: OTP 4 or 2)\n#define TMC5161_BBMCLKS_SHIFT                         8 // min.: 0, max.: 15, default: 0\n#define TMC5161_OTSELECT_MASK                         0x030000 // DRV_CONF // Selection of over temperature level 00: 150°C 01: 143°C 10: 136°C 11: 120°C (Reset Default = %00)\n#define TMC5161_OTSELECT_SHIFT                        16 // min.: 0, max.: 3, default: 0\n#define TMC5161_DRVSTRENGTH_MASK                      0x0C0000 // DRV_CONF // Selection of gate driver current 00: weak 01: weak+TC (medium at > 120°C) 10: medium 11: strong (Reset Default = %10)\n#define TMC5161_DRVSTRENGTH_SHIFT                     18 // min.: 0, max.: 3, default: 0\n#define TMC5161_FILT_ISENSE_MASK                      0x300000 // DRV_CONF // Filter time constant of sense amplifier to suppress ringing 00: low 1µs 01: medium 1.5µs 10: high 3µs 11: very high 3.5µs (Reset Default = %00)\n#define TMC5161_FILT_ISENSE_SHIFT                     20 // min.: 0, max.: 3, default: 0\n#define TMC5161_GLOBAL_SCALER_MASK                    0xFF // GLOBAL_SCALER // Global scaling of Motor current. This value is multiplied to the current scaling in order to adapt a drive to a certain motor type. This value should be chosen before tuning other settings, because it also influences chopper hysteresis. 0=Full Scale (or write 256) 32..255: 32/256 to 255/256 of max. current. Values >128 recommended for best results 1-31: Not allowed for operation\n#define TMC5161_GLOBAL_SCALER_SHIFT                   0 // min.: 0, max.: 255, default: 0\n#define TMC5161__MASK                                 0xFF00 // OFFSET_READ // Offset calibration result phase A (signed)\n#define TMC5161__SHIFT                                0 // min.: -128, max.: 127, default: 0\n//#define TMC5161__MASK                               0xFF // OFFSET_READ // Offset calibration result phase B (signed)\n//#define TMC5161__SHIFT                              0 // min.: -128, max.: 127, default: 0\n#define TMC5161_IHOLD_MASK                            0x1F // IHOLD_IRUN // Standstill current (0=1/32...31=32/32) In combination with stealthChop mode, setting IHOLD=0 allows to choose freewheeling or coil short circuit (passive braking) for motor stand still.\n#define TMC5161_IHOLD_SHIFT                           0 // min.: 0, max.: 31, default: 0\n#define TMC5161_IRUN_MASK                             0x1F00 // IHOLD_IRUN // Motor run current (0=1/32...31=32/32) Hint: Choose sense resistors in a way, that normal IRUN is 16 to 31 for best microstep performance.\n#define TMC5161_IRUN_SHIFT                            8 // min.: 0, max.: 31, default: 0\n#define TMC5161_IHOLDDELAY_MASK                       0x0F0000 // IHOLD_IRUN // Controls the number of clock cycles for motor power down after standstill is detected (stst=1) and TPOWERDOWN has expired. The smooth transition avoids a motor jerk upon power down. 0:  instant power down 1..15:  Delay per current reduction step in multiple of 2^18 clocks\n#define TMC5161_IHOLDDELAY_SHIFT                      16 // min.: 0, max.: 15, default: 0\n#define TMC5161_TPOWERDOWN_MASK                       0xFF // TPOWERDOWN // (Reset default=20) Sets the delay time from stand still (stst) detection to motor current power down. Time range is about 0 to 5.6 seconds. 0...((2^8)-1) * 2^18 tclk Attention: A minimum setting of 2 is required to allow automatic tuning of stealthChop PWM_OFFS_AUTO.\n#define TMC5161_TPOWERDOWN_SHIFT                      0 // min.: 0, max.: 255, default: 0\n#define TMC5161_TSTEP_MASK                            0x0FFFFF // TSTEP // Actual measured time between two 1/256 microsteps derived from the step input frequency in units of 1/fCLK. Measured value is (2^20)-1 in case of overflow or stand still. The TSTEP related threshold uses a hysteresis of 1/16 of the compare value to compensate for jitter in the clock or the step frequency: (Txxx*15/16)-1 is the lower compare value for each TSTEP based comparison. This means, that the lower switching velocity equals the calculated setting, but the upper switching velocity is higher as defined by the hysteresis setting.\n#define TMC5161_TSTEP_SHIFT                           0 // min.: 0, max.: 1048575, default: 0\n#define TMC5161_TPWMTHRS_MASK                         0x0FFFFF // TPWMTHRS // Sets the upper velocity for stealthChop voltage PWM mode.     For TSTEP = TPWMTHRS, stealthChop PWM mode is enabled, if configured. When the velocity exceeds the limit set by TPWMTHRS, the driver switches to spreadCycle. 0 = Disabled\n#define TMC5161_TPWMTHRS_SHIFT                        0 // min.: 0, max.: 1048575, default: 0\n#define TMC5161_TCOOLTHRS_MASK                        0x0FFFFF // TCOOLTHRS // This is the lower threshold velocity for switching on smart energy coolStep and stallGuard feature. (unsigned) Set this parameter to disable coolStep at low speeds, where it cannot work reliably. The stop on stall function (enable with sg_stop when using internal motion controller) and the stall output signal become enabled when exceeding this velocity. In non-dcStep mode, it becomes disabled again once the velocity falls below this threshold. TCOOLTHRS = TSTEP = THIGH: - coolStep is enabled, if configured - stealthChop voltage PWM mode is disabled TCOOLTHRS = TSTEP - Stop on stall and stall output signal is enabled, if configured\n#define TMC5161_TCOOLTHRS_SHIFT                       0 // min.: 0, max.: 1048575, default: 0\n#define TMC5161_THIGH_MASK                            0x0FFFFF // THIGH // This velocity setting allows velocity dependent switching into a different chopper mode and fullstepping to maximize torque. (unsigned) The stall detection feature becomes switched off for 2-3 electrical periods whenever passing THIGH threshold to compensate for the effect of switching modes. TSTEP = THIGH: - coolStep is disabled (motor runs with normal current scale) - stealthChop voltage PWM mode is disabled - If vhighchm is set, the chopper switches to chm=1 with TFD=0 (constant off time with slow decay, only). - chopSync2 is switched off (SYNC=0) - If vhighfs is set, the motor operates in fullstep mode and the stall detection becomes switched over to dcStep stall detection.\n#define TMC5161_THIGH_SHIFT                           0 // min.: 0, max.: 1048575, default: 0\n#define TMC5161_RAMPMODE_MASK                         0x03 // RAMPMODE // 0: Positioning mode (using all A, D and V parameters) 1: Velocity mode to positive VMAX (using AMAX acceleration) 2: Velocity mode to negative VMAX (using AMAX acceleration) 3: Hold mode (velocity remains unchanged, unless stop event occurs)\n#define TMC5161_RAMPMODE_SHIFT                        0 // min.: 0, max.: 3, default: 0\n#define TMC5161_XACTUAL_MASK                          0xFFFFFFFF // XACTUAL // Actual motor position (signed) Hint: This value normally should only be modified, when homing the drive. In positioning mode, modifying the register content will start a motion.\n#define TMC5161_XACTUAL_SHIFT                         0 // min.: -2147483648, max.: 2147483647, default: 0\n#define TMC5161_VACTUAL_MASK                          0xFFFFFF // VACTUAL // Actual motor velocity from ramp generator (signed) The sign matches the motion direction. A negative sign means motion to lower XACTUAL.\n#define TMC5161_VACTUAL_SHIFT                         0 // min.: -8388607, max.: 8388607, default: 0\n#define TMC5161_VSTART_MASK                           0x03FFFF // VSTART // Motor start velocity (unsigned) Set VSTOP = VSTART!\n#define TMC5161_VSTART_SHIFT                          0 // min.: 0, max.: 262143, default: 0\n#define TMC5161_A1_MASK                               0xFFFF // A1 // First acceleration between VSTART and V1 (unsigned)\n#define TMC5161_A1_SHIFT                              0 // min.: 0, max.: 65535, default: 0\n#define TMC5161_V1__MASK                              0x0FFFFF // V1 // First acceleration / deceleration phase threshold velocity (unsigned) 0: Disables A1 and D1 phase, use AMAX, DMAX only\n#define TMC5161_V1__SHIFT                             0 // min.: 0, max.: 1048575, default: 0\n#define TMC5161_AMAX_MASK                             0xFFFF // AMAX // Second acceleration between V1 and VMAX (unsigned) This is the acceleration and deceleration value for velocity mode.\n#define TMC5161_AMAX_SHIFT                            0 // min.: 0, max.: 65535, default: 0\n#define TMC5161_VMAX_MASK                             0x7FFFFF // VMAX // Motion ramp target velocity (for positioning ensure VMAX = VSTART) (unsigned) This is the target velocity in velocity mode. It can be changed any time during a motion.\n#define TMC5161_VMAX_SHIFT                            0 // min.: 0, max.: 8388096, default: 0\n#define TMC5161_DMAX_MASK                             0xFFFF // DMAX // Deceleration between VMAX and V1 (unsigned)\n#define TMC5161_DMAX_SHIFT                            0 // min.: 0, max.: 65535, default: 0\n#define TMC5161_D1_MASK                               0xFFFF // D1 // Deceleration between V1 and VSTOP (unsigned) Attention: Do not set 0 in positioning mode, even if V1=0!\n#define TMC5161_D1_SHIFT                              0 // min.: 1, max.: 65535, default: 0\n#define TMC5161_VSTOP_MASK                            0x03FFFF // VSTOP // Motor stop velocity (unsigned) Attention: Set VSTOP = VSTART! Attention: Do not set 0 in positioning mode, minimum 10 recommend!\n#define TMC5161_VSTOP_SHIFT                           0 // min.: 1, max.: 262143, default: 0\n#define TMC5161_TZEROWAIT_MASK                        0xFFFF // TZEROWAIT // Defines the waiting time after ramping down to zero velocity before next movement or direction inversion can start. Time range is about 0 to 2 seconds. This setting avoids excess acceleration e.g. from VSTOP to -VSTART.\n#define TMC5161_TZEROWAIT_SHIFT                       0 // min.: 0, max.: 65535, default: 0\n#define TMC5161_XTARGET_MASK                          0xFFFFFFFF // XTARGET // Target position for ramp mode (signed). Write a new target position to this register in order to activate the ramp generator positioning in RAMPMODE=0. Initialize all velocity, acceleration and deceleration parameters before. Hint: The position is allowed to wrap around, thus, XTARGET value optionally can be treated as an unsigned number. Hint: The maximum possible displacement is +/-((2^31)-1). Hint: When increasing V1, D1 or DMAX during a motion, rewrite XTARGET afterwards in order to trigger a second acceleration phase, if desired.\n#define TMC5161_XTARGET_SHIFT                         0 // min.: -2147483648, max.: 2147483647, default: 0\n#define TMC5161_VDCMIN_MASK                           0x7FFFFF // VDCMIN // Automatic commutation dcStep becomes enabled above velocity VDCMIN (unsigned) (only when using internal ramp generator, not for STEP/DIR interface - in STEP/DIR mode, dcStep becomes enabled by the external signal DCEN) In this mode, the actual position is determined by the sensorless motor commutation and becomes fed back to XACTUAL. In case the motor becomes heavily loaded, VDCMIN also is used as the minimum step velocity. Activate stop on stall (sg_stop) to detect step loss. 0: Disable, dcStep off |VACT| = VDCMIN = 256: - Triggers the same actions as exceeding THIGH setting. - Switches on automatic commutation dcStep Hint: Also set DCCTRL parameters in order to operate dcStep. (Only bits 22 - 8 are used for value and for comparison)\n#define TMC5161_VDCMIN_SHIFT                          0 // min.: 0, max.: 8388607, default: 0\n#define TMC5161_STOP_L_ENABLE_MASK                    0x01 // SW_MODE //\n#define TMC5161_STOP_L_ENABLE_SHIFT                   0 // min.: 0, max.: 1, default: 0\n#define TMC5161_STOP_R_ENABLE_MASK                    0x02 // SW_MODE //\n#define TMC5161_STOP_R_ENABLE_SHIFT                   1 // min.: 0, max.: 1, default: 0\n#define TMC5161_POL_STOP_L_MASK                       0x04 // SW_MODE // Sets the active polarity of the left reference switch input\n#define TMC5161_POL_STOP_L_SHIFT                      2 // min.: 0, max.: 1, default: 0\n#define TMC5161_POL_STOP_R_MASK                       0x08 // SW_MODE // Sets the active polarity of the right reference switch input\n#define TMC5161_POL_STOP_R_SHIFT                      3 // min.: 0, max.: 1, default: 0\n#define TMC5161_SWAP_LR_MASK                          0x10 // SW_MODE //\n#define TMC5161_SWAP_LR_SHIFT                         4 // min.: 0, max.: 1, default: 0\n#define TMC5161_LATCH_L_ACTIVE_MASK                   0x20 // SW_MODE //\n#define TMC5161_LATCH_L_ACTIVE_SHIFT                  5 // min.: 0, max.: 1, default: 0\n#define TMC5161_LATCH_L_INACTIVE_MASK                 0x40 // SW_MODE //\n#define TMC5161_LATCH_L_INACTIVE_SHIFT                6 // min.: 0, max.: 1, default: 0\n#define TMC5161_LATCH_R_ACTIVE_MASK                   0x80 // SW_MODE //\n#define TMC5161_LATCH_R_ACTIVE_SHIFT                  7 // min.: 0, max.: 1, default: 0\n#define TMC5161_LATCH_R_INACTIVE_MASK                 0x0100 // SW_MODE //\n#define TMC5161_LATCH_R_INACTIVE_SHIFT                8 // min.: 0, max.: 1, default: 0\n#define TMC5161_EN_LATCH_ENCODER_MASK                 0x0200 // SW_MODE //\n#define TMC5161_EN_LATCH_ENCODER_SHIFT                9 // min.: 0, max.: 1, default: 0\n#define TMC5161_SG_STOP_MASK                          0x0400 // SW_MODE //\n#define TMC5161_SG_STOP_SHIFT                         10 // min.: 0, max.: 1, default: 0\n#define TMC5161_EN_SOFTSTOP_MASK                      0x0800 // SW_MODE // The soft stop mode always uses the deceleration ramp settings DMAX, V1, D1, VSTOP and TZEROWAIT for stopping the motor. A stop occurs when the velocity sign matches the reference switch position (REFL for negative velocities, REFR for positive velocities) and the respective switch stop function is enabled. A hard stop also uses TZEROWAIT before the motor becomes released. Attention: Do not use soft stop in combination with stallGuard2.\n#define TMC5161_EN_SOFTSTOP_SHIFT                     11 // min.: 0, max.: 1, default: 0\n#define TMC5161_STATUS_STOP_L_MASK                    0x01 // RAMP_STAT //\n#define TMC5161_STATUS_STOP_L_SHIFT                   0 // min.: 0, max.: 1, default: 0\n#define TMC5161_STATUS_STOP_R_MASK                    0x02 // RAMP_STAT //\n#define TMC5161_STATUS_STOP_R_SHIFT                   1 // min.: 0, max.: 1, default: 0\n#define TMC5161_STATUS_LATCH_L_MASK                   0x04 // RAMP_STAT //\n#define TMC5161_STATUS_LATCH_L_SHIFT                  2 // min.: 0, max.: 1, default: 0\n#define TMC5161_STATUS_LATCH_R_MASK                   0x08 // RAMP_STAT //\n#define TMC5161_STATUS_LATCH_R_SHIFT                  3 // min.: 0, max.: 1, default: 0\n#define TMC5161_EVENT_STOP_L_MASK                     0x10 // RAMP_STAT //\n#define TMC5161_EVENT_STOP_L_SHIFT                    4 // min.: 0, max.: 1, default: 0\n#define TMC5161_EVENT_STOP_R_MASK                     0x20 // RAMP_STAT //\n#define TMC5161_EVENT_STOP_R_SHIFT                    5 // min.: 0, max.: 1, default: 0\n#define TMC5161_EVENT_STOP_SG_MASK                    0x40 // RAMP_STAT //\n#define TMC5161_EVENT_STOP_SG_SHIFT                   6 // min.: 0, max.: 1, default: 0\n#define TMC5161_EVENT_POS_REACHED_MASK                0x80 // RAMP_STAT //\n#define TMC5161_EVENT_POS_REACHED_SHIFT               7 // min.: 0, max.: 1, default: 0\n#define TMC5161_VELOCITY_REACHED_MASK                 0x0100 // RAMP_STAT //\n#define TMC5161_VELOCITY_REACHED_SHIFT                8 // min.: 0, max.: 1, default: 0\n#define TMC5161_POSITION_REACHED_MASK                 0x0200 // RAMP_STAT //\n#define TMC5161_POSITION_REACHED_SHIFT                9 // min.: 0, max.: 1, default: 0\n#define TMC5161_VZERO_MASK                            0x0400 // RAMP_STAT //\n#define TMC5161_VZERO_SHIFT                           10 // min.: 0, max.: 1, default: 0\n#define TMC5161_T_ZEROWAIT_ACTIVE_MASK                0x0800 // RAMP_STAT //\n#define TMC5161_T_ZEROWAIT_ACTIVE_SHIFT               11 // min.: 0, max.: 1, default: 0\n#define TMC5161_SECOND_MOVE_MASK                      0x1000 // RAMP_STAT //\n#define TMC5161_SECOND_MOVE_SHIFT                     12 // min.: 0, max.: 1, default: 0\n#define TMC5161_STATUS_SG_MASK                        0x2000 // RAMP_STAT //\n#define TMC5161_STATUS_SG_SHIFT                       13 // min.: 0, max.: 1, default: 0\n#define TMC5161_XLATCH_MASK                           0xFFFFFFFF // XLATCH // Ramp generator latch position, latches XACTUAL upon a programmable switch event (see SW_MODE). Hint: The encoder position can be latched to ENC_LATCH together with XLATCH to allow consistency checks.\n#define TMC5161_XLATCH_SHIFT                          0 // min.: 0, max.: 4294967295, default: 0\n#define TMC5161_POL_A_MASK                            0x01 // ENCMODE // Required A polarity for an N channel event\n#define TMC5161_POL_A_SHIFT                           0 // min.: 0, max.: 1, default: 0\n#define TMC5161_POL_B_MASK                            0x02 // ENCMODE // Required B polarity for an N channel event\n#define TMC5161_POL_B_SHIFT                           1 // min.: 0, max.: 1, default: 0\n#define TMC5161_POL_N_MASK                            0x04 // ENCMODE // Defines active polarity of N\n#define TMC5161_POL_N_SHIFT                           2 // min.: 0, max.: 1, default: 0\n#define TMC5161_IGNORE_AB_MASK                        0x08 // ENCMODE //\n#define TMC5161_IGNORE_AB_SHIFT                       3 // min.: 0, max.: 1, default: 0\n#define TMC5161_CLR_CONT_MASK                         0x10 // ENCMODE //\n#define TMC5161_CLR_CONT_SHIFT                        4 // min.: 0, max.: 1, default: 0\n#define TMC5161_CLR_ONCE_MASK                         0x20 // ENCMODE //\n#define TMC5161_CLR_ONCE_SHIFT                        5 // min.: 0, max.: 1, default: 0\n#define TMC5161_POS_EDGENEG_EDGE_MASK                 0xC0 // ENCMODE //\n#define TMC5161_POS_EDGENEG_EDGE_SHIFT                6 // min.: 0, max.: 3, default: 0\n#define TMC5161_CLR_ENC_X_MASK                        0x0100 // ENCMODE //\n#define TMC5161_CLR_ENC_X_SHIFT                       8 // min.: 0, max.: 1, default: 0\n#define TMC5161_LATCH_X_ACT_MASK                      0x0200 // ENCMODE //\n#define TMC5161_LATCH_X_ACT_SHIFT                     9 // min.: 0, max.: 1, default: 0\n#define TMC5161_ENC_SEL_DECIMAL_MASK                  0x0400 // ENCMODE //\n#define TMC5161_ENC_SEL_DECIMAL_SHIFT                 10 // min.: 0, max.: 1, default: 0\n#define TMC5161_X_ENC_MASK                            0xFFFFFFFF // X_ENC // Actual encoder position\n#define TMC5161_X_ENC_SHIFT                           0 // min.: -2147483648, max.: 2147483647, default: 0\n#define TMC5161_INTEGER_MASK                          0xFFFF0000 // ENC_CONST // Integer part of encoder constant\n#define TMC5161_INTEGER_SHIFT                         16 // min.: 0, max.: 65535, default: 0\n#define TMC5161_FRACTIONAL_MASK                       0xFFFF // ENC_CONST // Fractional part of encoder constant\n#define TMC5161_FRACTIONAL_SHIFT                      0 // min.: 0, max.: 65535, default: 0\n#define TMC5161_N_EVENT_MASK                          0x01 // ENC_STATUS //\n#define TMC5161_N_EVENT_SHIFT                         0 // min.: 0, max.: 1, default: 0\n#define TMC5161_DEVIATION_WARN_MASK                   0x02 // ENC_STATUS //\n#define TMC5161_DEVIATION_WARN_SHIFT                  1 // min.: 0, max.: 1, default: 0\n#define TMC5161_ENC_LATCH_MASK                        0xFFFFFFFF // ENC_LATCH // Encoder position X_ENC latched on N event\n#define TMC5161_ENC_LATCH_SHIFT                       0 // min.: -2147483648, max.: 2147483647, default: 0\n#define TMC5161_ENC_DEVIATION_MASK                    0x0FFFFF // ENC_DEVIATION // Maximum number of steps deviation between encoder counter and XACTUAL for deviation warning (flag deviation_warn). 0=Function is off.\n#define TMC5161_ENC_DEVIATION_SHIFT                   0 // min.: 0, max.: 1048575, default: 0\n#define TMC5161_OFS0_MASK                             0x01 // MSLUT[0] // microstep table entry 0\n#define TMC5161_OFS0_SHIFT                            0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS1_MASK                             0x02 // MSLUT[0] // microstep table entry 1\n#define TMC5161_OFS1_SHIFT                            1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS2_MASK                             0x04 // MSLUT[0] // microstep table entry 2\n#define TMC5161_OFS2_SHIFT                            2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS3_MASK                             0x08 // MSLUT[0] // microstep table entry 3\n#define TMC5161_OFS3_SHIFT                            3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS4_MASK                             0x10 // MSLUT[0] // microstep table entry 4\n#define TMC5161_OFS4_SHIFT                            4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS5_MASK                             0x20 // MSLUT[0] // microstep table entry 5\n#define TMC5161_OFS5_SHIFT                            5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS6_MASK                             0x40 // MSLUT[0] // microstep table entry 6\n#define TMC5161_OFS6_SHIFT                            6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS7_MASK                             0x80 // MSLUT[0] // microstep table entry 7\n#define TMC5161_OFS7_SHIFT                            7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS8_MASK                             0x0100 // MSLUT[0] // microstep table entry 8\n#define TMC5161_OFS8_SHIFT                            8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS9_MASK                             0x0200 // MSLUT[0] // microstep table entry 9\n#define TMC5161_OFS9_SHIFT                            9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS10_MASK                            0x0400 // MSLUT[0] // microstep table entry 10\n#define TMC5161_OFS10_SHIFT                           10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS11_MASK                            0x0800 // MSLUT[0] // microstep table entry 11\n#define TMC5161_OFS11_SHIFT                           11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS12_MASK                            0x1000 // MSLUT[0] // microstep table entry 12\n#define TMC5161_OFS12_SHIFT                           12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS13_MASK                            0x2000 // MSLUT[0] // microstep table entry 13\n#define TMC5161_OFS13_SHIFT                           13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS14_MASK                            0x4000 // MSLUT[0] // microstep table entry 14\n#define TMC5161_OFS14_SHIFT                           14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS15_MASK                            0x8000 // MSLUT[0] // microstep table entry 15\n#define TMC5161_OFS15_SHIFT                           15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS16_MASK                            0x010000 // MSLUT[0] // microstep table entry 16\n#define TMC5161_OFS16_SHIFT                           16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS17_MASK                            0x020000 // MSLUT[0] // microstep table entry 17\n#define TMC5161_OFS17_SHIFT                           17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS18_MASK                            0x040000 // MSLUT[0] // microstep table entry 18\n#define TMC5161_OFS18_SHIFT                           18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS19_MASK                            0x080000 // MSLUT[0] // microstep table entry 19\n#define TMC5161_OFS19_SHIFT                           19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS20_MASK                            0x100000 // MSLUT[0] // microstep table entry 20\n#define TMC5161_OFS20_SHIFT                           20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS21_MASK                            0x200000 // MSLUT[0] // microstep table entry 21\n#define TMC5161_OFS21_SHIFT                           21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS22_MASK                            0x400000 // MSLUT[0] // microstep table entry 22\n#define TMC5161_OFS22_SHIFT                           22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS23_MASK                            0x800000 // MSLUT[0] // microstep table entry 23\n#define TMC5161_OFS23_SHIFT                           23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS24_MASK                            0x01000000 // MSLUT[0] // microstep table entry 24\n#define TMC5161_OFS24_SHIFT                           24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS25_MASK                            0x02000000 // MSLUT[0] // microstep table entry 25\n#define TMC5161_OFS25_SHIFT                           25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS26_MASK                            0x04000000 // MSLUT[0] // microstep table entry 26\n#define TMC5161_OFS26_SHIFT                           26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS27_MASK                            0x08000000 // MSLUT[0] // microstep table entry 27\n#define TMC5161_OFS27_SHIFT                           27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS28_MASK                            0x10000000 // MSLUT[0] // microstep table entry 28\n#define TMC5161_OFS28_SHIFT                           28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS29_MASK                            0x20000000 // MSLUT[0] // microstep table entry 29\n#define TMC5161_OFS29_SHIFT                           29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS30_MASK                            0x40000000 // MSLUT[0] // microstep table entry 30\n#define TMC5161_OFS30_SHIFT                           30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS31_MASK                            0x80000000 // MSLUT[0] // microstep table entry 31\n#define TMC5161_OFS31_SHIFT                           31 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS32_MASK                            0x01 // MSLUT[1] // microstep table entry 32\n#define TMC5161_OFS32_SHIFT                           0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS33_MASK                            0x02 // MSLUT[1] // microstep table entry 33\n#define TMC5161_OFS33_SHIFT                           1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS34_MASK                            0x04 // MSLUT[1] // microstep table entry 34\n#define TMC5161_OFS34_SHIFT                           2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS35_MASK                            0x08 // MSLUT[1] // microstep table entry 35\n#define TMC5161_OFS35_SHIFT                           3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS36_MASK                            0x10 // MSLUT[1] // microstep table entry 36\n#define TMC5161_OFS36_SHIFT                           4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS37_MASK                            0x20 // MSLUT[1] // microstep table entry 37\n#define TMC5161_OFS37_SHIFT                           5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS38_MASK                            0x40 // MSLUT[1] // microstep table entry 38\n#define TMC5161_OFS38_SHIFT                           6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS39_MASK                            0x80 // MSLUT[1] // microstep table entry 39\n#define TMC5161_OFS39_SHIFT                           7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS40_MASK                            0x0100 // MSLUT[1] // microstep table entry 40\n#define TMC5161_OFS40_SHIFT                           8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS41_MASK                            0x0200 // MSLUT[1] // microstep table entry 41\n#define TMC5161_OFS41_SHIFT                           9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS42_MASK                            0x0400 // MSLUT[1] // microstep table entry 42\n#define TMC5161_OFS42_SHIFT                           10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS43_MASK                            0x0800 // MSLUT[1] // microstep table entry 43\n#define TMC5161_OFS43_SHIFT                           11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS44_MASK                            0x1000 // MSLUT[1] // microstep table entry 44\n#define TMC5161_OFS44_SHIFT                           12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS45_MASK                            0x2000 // MSLUT[1] // microstep table entry 45\n#define TMC5161_OFS45_SHIFT                           13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS46_MASK                            0x4000 // MSLUT[1] // microstep table entry 46\n#define TMC5161_OFS46_SHIFT                           14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS47_MASK                            0x8000 // MSLUT[1] // microstep table entry 47\n#define TMC5161_OFS47_SHIFT                           15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS48_MASK                            0x010000 // MSLUT[1] // microstep table entry 48\n#define TMC5161_OFS48_SHIFT                           16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS49_MASK                            0x020000 // MSLUT[1] // microstep table entry 49\n#define TMC5161_OFS49_SHIFT                           17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS50_MASK                            0x040000 // MSLUT[1] // microstep table entry 50\n#define TMC5161_OFS50_SHIFT                           18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS51_MASK                            0x080000 // MSLUT[1] // microstep table entry 51\n#define TMC5161_OFS51_SHIFT                           19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS52_MASK                            0x100000 // MSLUT[1] // microstep table entry 52\n#define TMC5161_OFS52_SHIFT                           20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS53_MASK                            0x200000 // MSLUT[1] // microstep table entry 53\n#define TMC5161_OFS53_SHIFT                           21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS54_MASK                            0x400000 // MSLUT[1] // microstep table entry 54\n#define TMC5161_OFS54_SHIFT                           22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS55_MASK                            0x800000 // MSLUT[1] // microstep table entry 55\n#define TMC5161_OFS55_SHIFT                           23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS56_MASK                            0x01000000 // MSLUT[1] // microstep table entry 56\n#define TMC5161_OFS56_SHIFT                           24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS57_MASK                            0x02000000 // MSLUT[1] // microstep table entry 57\n#define TMC5161_OFS57_SHIFT                           25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS58_MASK                            0x04000000 // MSLUT[1] // microstep table entry 58\n#define TMC5161_OFS58_SHIFT                           26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS59_MASK                            0x08000000 // MSLUT[1] // microstep table entry 59\n#define TMC5161_OFS59_SHIFT                           27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS60_MASK                            0x10000000 // MSLUT[1] // microstep table entry 60\n#define TMC5161_OFS60_SHIFT                           28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS61_MASK                            0x20000000 // MSLUT[1] // microstep table entry 61\n#define TMC5161_OFS61_SHIFT                           29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS62_MASK                            0x40000000 // MSLUT[1] // microstep table entry 62\n#define TMC5161_OFS62_SHIFT                           30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS63_MASK                            0x80000000 // MSLUT[1] // microstep table entry 63\n#define TMC5161_OFS63_SHIFT                           31 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS64_MASK                            0x01 // MSLUT[2] // microstep table entry 64\n#define TMC5161_OFS64_SHIFT                           0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS65_MASK                            0x02 // MSLUT[2] // microstep table entry 65\n#define TMC5161_OFS65_SHIFT                           1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS66_MASK                            0x04 // MSLUT[2] // microstep table entry 66\n#define TMC5161_OFS66_SHIFT                           2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS67_MASK                            0x08 // MSLUT[2] // microstep table entry 67\n#define TMC5161_OFS67_SHIFT                           3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS68_MASK                            0x10 // MSLUT[2] // microstep table entry 68\n#define TMC5161_OFS68_SHIFT                           4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS69_MASK                            0x20 // MSLUT[2] // microstep table entry 69\n#define TMC5161_OFS69_SHIFT                           5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS70_MASK                            0x40 // MSLUT[2] // microstep table entry 70\n#define TMC5161_OFS70_SHIFT                           6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS71_MASK                            0x80 // MSLUT[2] // microstep table entry 71\n#define TMC5161_OFS71_SHIFT                           7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS72_MASK                            0x0100 // MSLUT[2] // microstep table entry 72\n#define TMC5161_OFS72_SHIFT                           8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS73_MASK                            0x0200 // MSLUT[2] // microstep table entry 73\n#define TMC5161_OFS73_SHIFT                           9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS74_MASK                            0x0400 // MSLUT[2] // microstep table entry 74\n#define TMC5161_OFS74_SHIFT                           10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS75_MASK                            0x0800 // MSLUT[2] // microstep table entry 75\n#define TMC5161_OFS75_SHIFT                           11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS76_MASK                            0x1000 // MSLUT[2] // microstep table entry 76\n#define TMC5161_OFS76_SHIFT                           12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS77_MASK                            0x2000 // MSLUT[2] // microstep table entry 77\n#define TMC5161_OFS77_SHIFT                           13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS78_MASK                            0x4000 // MSLUT[2] // microstep table entry 78\n#define TMC5161_OFS78_SHIFT                           14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS79_MASK                            0x8000 // MSLUT[2] // microstep table entry 79\n#define TMC5161_OFS79_SHIFT                           15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS80_MASK                            0x010000 // MSLUT[2] // microstep table entry 80\n#define TMC5161_OFS80_SHIFT                           16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS81_MASK                            0x020000 // MSLUT[2] // microstep table entry 81\n#define TMC5161_OFS81_SHIFT                           17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS82_MASK                            0x040000 // MSLUT[2] // microstep table entry 82\n#define TMC5161_OFS82_SHIFT                           18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS83_MASK                            0x080000 // MSLUT[2] // microstep table entry 83\n#define TMC5161_OFS83_SHIFT                           19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS84_MASK                            0x100000 // MSLUT[2] // microstep table entry 84\n#define TMC5161_OFS84_SHIFT                           20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS85_MASK                            0x200000 // MSLUT[2] // microstep table entry 85\n#define TMC5161_OFS85_SHIFT                           21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS86_MASK                            0x400000 // MSLUT[2] // microstep table entry 86\n#define TMC5161_OFS86_SHIFT                           22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS87_MASK                            0x800000 // MSLUT[2] // microstep table entry 87\n#define TMC5161_OFS87_SHIFT                           23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS88_MASK                            0x01000000 // MSLUT[2] // microstep table entry 88\n#define TMC5161_OFS88_SHIFT                           24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS89_MASK                            0x02000000 // MSLUT[2] // microstep table entry 89\n#define TMC5161_OFS89_SHIFT                           25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS90_MASK                            0x04000000 // MSLUT[2] // microstep table entry 90\n#define TMC5161_OFS90_SHIFT                           26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS91_MASK                            0x08000000 // MSLUT[2] // microstep table entry 91\n#define TMC5161_OFS91_SHIFT                           27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS92_MASK                            0x10000000 // MSLUT[2] // microstep table entry 92\n#define TMC5161_OFS92_SHIFT                           28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS93_MASK                            0x20000000 // MSLUT[2] // microstep table entry 93\n#define TMC5161_OFS93_SHIFT                           29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS94_MASK                            0x40000000 // MSLUT[2] // microstep table entry 94\n#define TMC5161_OFS94_SHIFT                           30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS95_MASK                            0x80000000 // MSLUT[2] // microstep table entry 95\n#define TMC5161_OFS95_SHIFT                           31 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS96_MASK                            0x01 // MSLUT[3] // microstep table entry 96\n#define TMC5161_OFS96_SHIFT                           0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS97_MASK                            0x02 // MSLUT[3] // microstep table entry 97\n#define TMC5161_OFS97_SHIFT                           1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS98_MASK                            0x04 // MSLUT[3] // microstep table entry 98\n#define TMC5161_OFS98_SHIFT                           2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS99_MASK                            0x08 // MSLUT[3] // microstep table entry 99\n#define TMC5161_OFS99_SHIFT                           3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS100_MASK                           0x10 // MSLUT[3] // microstep table entry 100\n#define TMC5161_OFS100_SHIFT                          4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS101_MASK                           0x20 // MSLUT[3] // microstep table entry 101\n#define TMC5161_OFS101_SHIFT                          5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS102_MASK                           0x40 // MSLUT[3] // microstep table entry 102\n#define TMC5161_OFS102_SHIFT                          6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS103_MASK                           0x80 // MSLUT[3] // microstep table entry 103\n#define TMC5161_OFS103_SHIFT                          7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS104_MASK                           0x0100 // MSLUT[3] // microstep table entry 104\n#define TMC5161_OFS104_SHIFT                          8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS105_MASK                           0x0200 // MSLUT[3] // microstep table entry 105\n#define TMC5161_OFS105_SHIFT                          9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS106_MASK                           0x0400 // MSLUT[3] // microstep table entry 106\n#define TMC5161_OFS106_SHIFT                          10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS107_MASK                           0x0800 // MSLUT[3] // microstep table entry 107\n#define TMC5161_OFS107_SHIFT                          11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS108_MASK                           0x1000 // MSLUT[3] // microstep table entry 108\n#define TMC5161_OFS108_SHIFT                          12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS109_MASK                           0x2000 // MSLUT[3] // microstep table entry 109\n#define TMC5161_OFS109_SHIFT                          13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS110_MASK                           0x4000 // MSLUT[3] // microstep table entry 110\n#define TMC5161_OFS110_SHIFT                          14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS111_MASK                           0x8000 // MSLUT[3] // microstep table entry 111\n#define TMC5161_OFS111_SHIFT                          15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS112_MASK                           0x010000 // MSLUT[3] // microstep table entry 112\n#define TMC5161_OFS112_SHIFT                          16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS113_MASK                           0x020000 // MSLUT[3] // microstep table entry 113\n#define TMC5161_OFS113_SHIFT                          17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS114_MASK                           0x040000 // MSLUT[3] // microstep table entry 114\n#define TMC5161_OFS114_SHIFT                          18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS115_MASK                           0x080000 // MSLUT[3] // microstep table entry 115\n#define TMC5161_OFS115_SHIFT                          19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS116_MASK                           0x100000 // MSLUT[3] // microstep table entry 116\n#define TMC5161_OFS116_SHIFT                          20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS117_MASK                           0x200000 // MSLUT[3] // microstep table entry 117\n#define TMC5161_OFS117_SHIFT                          21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS118_MASK                           0x400000 // MSLUT[3] // microstep table entry 118\n#define TMC5161_OFS118_SHIFT                          22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS119_MASK                           0x800000 // MSLUT[3] // microstep table entry 119\n#define TMC5161_OFS119_SHIFT                          23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS120_MASK                           0x01000000 // MSLUT[3] // microstep table entry 120\n#define TMC5161_OFS120_SHIFT                          24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS121_MASK                           0x02000000 // MSLUT[3] // microstep table entry 121\n#define TMC5161_OFS121_SHIFT                          25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS122_MASK                           0x04000000 // MSLUT[3] // microstep table entry 122\n#define TMC5161_OFS122_SHIFT                          26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS123_MASK                           0x08000000 // MSLUT[3] // microstep table entry 123\n#define TMC5161_OFS123_SHIFT                          27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS124_MASK                           0x10000000 // MSLUT[3] // microstep table entry 124\n#define TMC5161_OFS124_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS125_MASK                           0x20000000 // MSLUT[3] // microstep table entry 125\n#define TMC5161_OFS125_SHIFT                          29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS126_MASK                           0x40000000 // MSLUT[3] // microstep table entry 126\n#define TMC5161_OFS126_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS127_MASK                           0x80000000 // MSLUT[3] // microstep table entry 127\n#define TMC5161_OFS127_SHIFT                          31 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS128_MASK                           0x01 // MSLUT[4] // microstep table entry 128\n#define TMC5161_OFS128_SHIFT                          0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS129_MASK                           0x02 // MSLUT[4] // microstep table entry 129\n#define TMC5161_OFS129_SHIFT                          1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS130_MASK                           0x04 // MSLUT[4] // microstep table entry 130\n#define TMC5161_OFS130_SHIFT                          2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS131_MASK                           0x08 // MSLUT[4] // microstep table entry 131\n#define TMC5161_OFS131_SHIFT                          3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS132_MASK                           0x10 // MSLUT[4] // microstep table entry 132\n#define TMC5161_OFS132_SHIFT                          4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS133_MASK                           0x20 // MSLUT[4] // microstep table entry 133\n#define TMC5161_OFS133_SHIFT                          5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS134_MASK                           0x40 // MSLUT[4] // microstep table entry 134\n#define TMC5161_OFS134_SHIFT                          6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS135_MASK                           0x80 // MSLUT[4] // microstep table entry 135\n#define TMC5161_OFS135_SHIFT                          7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS136_MASK                           0x0100 // MSLUT[4] // microstep table entry 136\n#define TMC5161_OFS136_SHIFT                          8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS137_MASK                           0x0200 // MSLUT[4] // microstep table entry 137\n#define TMC5161_OFS137_SHIFT                          9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS138_MASK                           0x0400 // MSLUT[4] // microstep table entry 138\n#define TMC5161_OFS138_SHIFT                          10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS139_MASK                           0x0800 // MSLUT[4] // microstep table entry 139\n#define TMC5161_OFS139_SHIFT                          11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS140_MASK                           0x1000 // MSLUT[4] // microstep table entry 140\n#define TMC5161_OFS140_SHIFT                          12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS141_MASK                           0x2000 // MSLUT[4] // microstep table entry 141\n#define TMC5161_OFS141_SHIFT                          13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS142_MASK                           0x4000 // MSLUT[4] // microstep table entry 142\n#define TMC5161_OFS142_SHIFT                          14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS143_MASK                           0x8000 // MSLUT[4] // microstep table entry 143\n#define TMC5161_OFS143_SHIFT                          15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS144_MASK                           0x010000 // MSLUT[4] // microstep table entry 144\n#define TMC5161_OFS144_SHIFT                          16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS145_MASK                           0x020000 // MSLUT[4] // microstep table entry 145\n#define TMC5161_OFS145_SHIFT                          17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS146_MASK                           0x040000 // MSLUT[4] // microstep table entry 146\n#define TMC5161_OFS146_SHIFT                          18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS147_MASK                           0x080000 // MSLUT[4] // microstep table entry 147\n#define TMC5161_OFS147_SHIFT                          19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS148_MASK                           0x100000 // MSLUT[4] // microstep table entry 148\n#define TMC5161_OFS148_SHIFT                          20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS149_MASK                           0x200000 // MSLUT[4] // microstep table entry 149\n#define TMC5161_OFS149_SHIFT                          21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS150_MASK                           0x400000 // MSLUT[4] // microstep table entry 150\n#define TMC5161_OFS150_SHIFT                          22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS151_MASK                           0x800000 // MSLUT[4] // microstep table entry 151\n#define TMC5161_OFS151_SHIFT                          23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS152_MASK                           0x01000000 // MSLUT[4] // microstep table entry 152\n#define TMC5161_OFS152_SHIFT                          24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS153_MASK                           0x02000000 // MSLUT[4] // microstep table entry 153\n#define TMC5161_OFS153_SHIFT                          25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS154_MASK                           0x04000000 // MSLUT[4] // microstep table entry 154\n#define TMC5161_OFS154_SHIFT                          26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS155_MASK                           0x08000000 // MSLUT[4] // microstep table entry 155\n#define TMC5161_OFS155_SHIFT                          27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS156_MASK                           0x10000000 // MSLUT[4] // microstep table entry 156\n#define TMC5161_OFS156_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS157_MASK                           0x20000000 // MSLUT[4] // microstep table entry 157\n#define TMC5161_OFS157_SHIFT                          29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS158_MASK                           0x40000000 // MSLUT[4] // microstep table entry 158\n#define TMC5161_OFS158_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS159_MASK                           0x80000000 // MSLUT[4] // microstep table entry 159\n#define TMC5161_OFS159_SHIFT                          31 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS160_MASK                           0x01 // MSLUT[5] // microstep table entry 160\n#define TMC5161_OFS160_SHIFT                          0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS161_MASK                           0x02 // MSLUT[5] // microstep table entry 161\n#define TMC5161_OFS161_SHIFT                          1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS162_MASK                           0x04 // MSLUT[5] // microstep table entry 162\n#define TMC5161_OFS162_SHIFT                          2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS163_MASK                           0x08 // MSLUT[5] // microstep table entry 163\n#define TMC5161_OFS163_SHIFT                          3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS164_MASK                           0x10 // MSLUT[5] // microstep table entry 164\n#define TMC5161_OFS164_SHIFT                          4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS165_MASK                           0x20 // MSLUT[5] // microstep table entry 165\n#define TMC5161_OFS165_SHIFT                          5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS166_MASK                           0x40 // MSLUT[5] // microstep table entry 166\n#define TMC5161_OFS166_SHIFT                          6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS167_MASK                           0x80 // MSLUT[5] // microstep table entry 167\n#define TMC5161_OFS167_SHIFT                          7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS168_MASK                           0x0100 // MSLUT[5] // microstep table entry 168\n#define TMC5161_OFS168_SHIFT                          8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS169_MASK                           0x0200 // MSLUT[5] // microstep table entry 169\n#define TMC5161_OFS169_SHIFT                          9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS170_MASK                           0x0400 // MSLUT[5] // microstep table entry 170\n#define TMC5161_OFS170_SHIFT                          10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS171_MASK                           0x0800 // MSLUT[5] // microstep table entry 171\n#define TMC5161_OFS171_SHIFT                          11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS172_MASK                           0x1000 // MSLUT[5] // microstep table entry 172\n#define TMC5161_OFS172_SHIFT                          12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS173_MASK                           0x2000 // MSLUT[5] // microstep table entry 173\n#define TMC5161_OFS173_SHIFT                          13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS174_MASK                           0x4000 // MSLUT[5] // microstep table entry 174\n#define TMC5161_OFS174_SHIFT                          14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS175_MASK                           0x8000 // MSLUT[5] // microstep table entry 175\n#define TMC5161_OFS175_SHIFT                          15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS176_MASK                           0x010000 // MSLUT[5] // microstep table entry 176\n#define TMC5161_OFS176_SHIFT                          16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS177_MASK                           0x020000 // MSLUT[5] // microstep table entry 177\n#define TMC5161_OFS177_SHIFT                          17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS178_MASK                           0x040000 // MSLUT[5] // microstep table entry 178\n#define TMC5161_OFS178_SHIFT                          18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS179_MASK                           0x080000 // MSLUT[5] // microstep table entry 179\n#define TMC5161_OFS179_SHIFT                          19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS180_MASK                           0x100000 // MSLUT[5] // microstep table entry 180\n#define TMC5161_OFS180_SHIFT                          20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS181_MASK                           0x200000 // MSLUT[5] // microstep table entry 181\n#define TMC5161_OFS181_SHIFT                          21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS182_MASK                           0x400000 // MSLUT[5] // microstep table entry 182\n#define TMC5161_OFS182_SHIFT                          22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS183_MASK                           0x800000 // MSLUT[5] // microstep table entry 183\n#define TMC5161_OFS183_SHIFT                          23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS184_MASK                           0x01000000 // MSLUT[5] // microstep table entry 184\n#define TMC5161_OFS184_SHIFT                          24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS185_MASK                           0x02000000 // MSLUT[5] // microstep table entry 185\n#define TMC5161_OFS185_SHIFT                          25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS186_MASK                           0x04000000 // MSLUT[5] // microstep table entry 186\n#define TMC5161_OFS186_SHIFT                          26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS187_MASK                           0x08000000 // MSLUT[5] // microstep table entry 187\n#define TMC5161_OFS187_SHIFT                          27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS188_MASK                           0x10000000 // MSLUT[5] // microstep table entry 188\n#define TMC5161_OFS188_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS189_MASK                           0x20000000 // MSLUT[5] // microstep table entry 189\n#define TMC5161_OFS189_SHIFT                          29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS190_MASK                           0x40000000 // MSLUT[5] // microstep table entry 190\n#define TMC5161_OFS190_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS191_MASK                           0x80000000 // MSLUT[5] // microstep table entry 191\n#define TMC5161_OFS191_SHIFT                          31 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS192_MASK                           0x01 // MSLUT[6] // microstep table entry 192\n#define TMC5161_OFS192_SHIFT                          0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS193_MASK                           0x02 // MSLUT[6] // microstep table entry 193\n#define TMC5161_OFS193_SHIFT                          1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS194_MASK                           0x04 // MSLUT[6] // microstep table entry 194\n#define TMC5161_OFS194_SHIFT                          2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS195_MASK                           0x08 // MSLUT[6] // microstep table entry 195\n#define TMC5161_OFS195_SHIFT                          3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS196_MASK                           0x10 // MSLUT[6] // microstep table entry 196\n#define TMC5161_OFS196_SHIFT                          4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS197_MASK                           0x20 // MSLUT[6] // microstep table entry 197\n#define TMC5161_OFS197_SHIFT                          5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS198_MASK                           0x40 // MSLUT[6] // microstep table entry 198\n#define TMC5161_OFS198_SHIFT                          6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS199_MASK                           0x80 // MSLUT[6] // microstep table entry 199\n#define TMC5161_OFS199_SHIFT                          7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS200_MASK                           0x0100 // MSLUT[6] // microstep table entry 200\n#define TMC5161_OFS200_SHIFT                          8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS201_MASK                           0x0200 // MSLUT[6] // microstep table entry 201\n#define TMC5161_OFS201_SHIFT                          9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS202_MASK                           0x0400 // MSLUT[6] // microstep table entry 202\n#define TMC5161_OFS202_SHIFT                          10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS203_MASK                           0x0800 // MSLUT[6] // microstep table entry 203\n#define TMC5161_OFS203_SHIFT                          11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS204_MASK                           0x1000 // MSLUT[6] // microstep table entry 204\n#define TMC5161_OFS204_SHIFT                          12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS205_MASK                           0x2000 // MSLUT[6] // microstep table entry 205\n#define TMC5161_OFS205_SHIFT                          13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS206_MASK                           0x4000 // MSLUT[6] // microstep table entry 206\n#define TMC5161_OFS206_SHIFT                          14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS207_MASK                           0x8000 // MSLUT[6] // microstep table entry 207\n#define TMC5161_OFS207_SHIFT                          15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS208_MASK                           0x010000 // MSLUT[6] // microstep table entry 208\n#define TMC5161_OFS208_SHIFT                          16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS209_MASK                           0x020000 // MSLUT[6] // microstep table entry 209\n#define TMC5161_OFS209_SHIFT                          17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS210_MASK                           0x040000 // MSLUT[6] // microstep table entry 210\n#define TMC5161_OFS210_SHIFT                          18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS211_MASK                           0x080000 // MSLUT[6] // microstep table entry 211\n#define TMC5161_OFS211_SHIFT                          19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS212_MASK                           0x100000 // MSLUT[6] // microstep table entry 212\n#define TMC5161_OFS212_SHIFT                          20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS213_MASK                           0x200000 // MSLUT[6] // microstep table entry 213\n#define TMC5161_OFS213_SHIFT                          21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS214_MASK                           0x400000 // MSLUT[6] // microstep table entry 214\n#define TMC5161_OFS214_SHIFT                          22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS215_MASK                           0x800000 // MSLUT[6] // microstep table entry 215\n#define TMC5161_OFS215_SHIFT                          23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS216_MASK                           0x01000000 // MSLUT[6] // microstep table entry 216\n#define TMC5161_OFS216_SHIFT                          24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS217_MASK                           0x02000000 // MSLUT[6] // microstep table entry 217\n#define TMC5161_OFS217_SHIFT                          25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS218_MASK                           0x04000000 // MSLUT[6] // microstep table entry 218\n#define TMC5161_OFS218_SHIFT                          26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS219_MASK                           0x08000000 // MSLUT[6] // microstep table entry 219\n#define TMC5161_OFS219_SHIFT                          27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS220_MASK                           0x10000000 // MSLUT[6] // microstep table entry 220\n#define TMC5161_OFS220_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS221_MASK                           0x20000000 // MSLUT[6] // microstep table entry 221\n#define TMC5161_OFS221_SHIFT                          29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS222_MASK                           0x40000000 // MSLUT[6] // microstep table entry 222\n#define TMC5161_OFS222_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS223_MASK                           0x80000000 // MSLUT[6] // microstep table entry 223\n#define TMC5161_OFS223_SHIFT                          31 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS224_MASK                           0x01 // MSLUT[7] // microstep table entry 224\n#define TMC5161_OFS224_SHIFT                          0 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS225_MASK                           0x02 // MSLUT[7] // microstep table entry 225\n#define TMC5161_OFS225_SHIFT                          1 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS226_MASK                           0x04 // MSLUT[7] // microstep table entry 226\n#define TMC5161_OFS226_SHIFT                          2 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS227_MASK                           0x08 // MSLUT[7] // microstep table entry 227\n#define TMC5161_OFS227_SHIFT                          3 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS228_MASK                           0x10 // MSLUT[7] // microstep table entry 228\n#define TMC5161_OFS228_SHIFT                          4 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS229_MASK                           0x20 // MSLUT[7] // microstep table entry 229\n#define TMC5161_OFS229_SHIFT                          5 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS230_MASK                           0x40 // MSLUT[7] // microstep table entry 230\n#define TMC5161_OFS230_SHIFT                          6 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS231_MASK                           0x80 // MSLUT[7] // microstep table entry 231\n#define TMC5161_OFS231_SHIFT                          7 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS232_MASK                           0x0100 // MSLUT[7] // microstep table entry 232\n#define TMC5161_OFS232_SHIFT                          8 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS233_MASK                           0x0200 // MSLUT[7] // microstep table entry 233\n#define TMC5161_OFS233_SHIFT                          9 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS234_MASK                           0x0400 // MSLUT[7] // microstep table entry 234\n#define TMC5161_OFS234_SHIFT                          10 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS235_MASK                           0x0800 // MSLUT[7] // microstep table entry 235\n#define TMC5161_OFS235_SHIFT                          11 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS236_MASK                           0x1000 // MSLUT[7] // microstep table entry 236\n#define TMC5161_OFS236_SHIFT                          12 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS237_MASK                           0x2000 // MSLUT[7] // microstep table entry 237\n#define TMC5161_OFS237_SHIFT                          13 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS238_MASK                           0x4000 // MSLUT[7] // microstep table entry 238\n#define TMC5161_OFS238_SHIFT                          14 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS239_MASK                           0x8000 // MSLUT[7] // microstep table entry 239\n#define TMC5161_OFS239_SHIFT                          15 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS240_MASK                           0x010000 // MSLUT[7] // microstep table entry 240\n#define TMC5161_OFS240_SHIFT                          16 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS241_MASK                           0x020000 // MSLUT[7] // microstep table entry 241\n#define TMC5161_OFS241_SHIFT                          17 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS242_MASK                           0x040000 // MSLUT[7] // microstep table entry 242\n#define TMC5161_OFS242_SHIFT                          18 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS243_MASK                           0x080000 // MSLUT[7] // microstep table entry 243\n#define TMC5161_OFS243_SHIFT                          19 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS244_MASK                           0x100000 // MSLUT[7] // microstep table entry 244\n#define TMC5161_OFS244_SHIFT                          20 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS245_MASK                           0x200000 // MSLUT[7] // microstep table entry 245\n#define TMC5161_OFS245_SHIFT                          21 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS246_MASK                           0x400000 // MSLUT[7] // microstep table entry 246\n#define TMC5161_OFS246_SHIFT                          22 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS247_MASK                           0x800000 // MSLUT[7] // microstep table entry 247\n#define TMC5161_OFS247_SHIFT                          23 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS248_MASK                           0x01000000 // MSLUT[7] // microstep table entry 248\n#define TMC5161_OFS248_SHIFT                          24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS249_MASK                           0x02000000 // MSLUT[7] // microstep table entry 249\n#define TMC5161_OFS249_SHIFT                          25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS250_MASK                           0x04000000 // MSLUT[7] // microstep table entry 250\n#define TMC5161_OFS250_SHIFT                          26 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS251_MASK                           0x08000000 // MSLUT[7] // microstep table entry 251\n#define TMC5161_OFS251_SHIFT                          27 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS252_MASK                           0x10000000 // MSLUT[7] // microstep table entry 252\n#define TMC5161_OFS252_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS253_MASK                           0x20000000 // MSLUT[7] // microstep table entry 253\n#define TMC5161_OFS253_SHIFT                          29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS254_MASK                           0x40000000 // MSLUT[7] // microstep table entry 254\n#define TMC5161_OFS254_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_OFS255_MASK                           0x80000000 // MSLUT[7] // microstep table entry 255\n#define TMC5161_OFS255_SHIFT                          31 // min.: 0, max.: 1, default: 0\n#define TMC5161_W0_MASK                               0x03 // MSLUTSEL // LUT width select from ofs0 to ofs(X1-1)\n#define TMC5161_W0_SHIFT                              0 // min.: 0, max.: 3, default: 0\n#define TMC5161_W1_MASK                               0x0C // MSLUTSEL // LUT width select from ofs(X1) to ofs(X2-1)\n#define TMC5161_W1_SHIFT                              2 // min.: 0, max.: 3, default: 0\n#define TMC5161_W2_MASK                               0x30 // MSLUTSEL // LUT width select from ofs(X2) to ofs(X3-1)\n#define TMC5161_W2_SHIFT                              4 // min.: 0, max.: 3, default: 0\n#define TMC5161_W3_MASK                               0xC0 // MSLUTSEL // LUT width select from ofs(X3) to ofs255\n#define TMC5161_W3_SHIFT                              6 // min.: 0, max.: 3, default: 0\n#define TMC5161_X1_MASK                               0xFF00 // MSLUTSEL // LUT segment 1 start\n#define TMC5161_X1_SHIFT                              8 // min.: 0, max.: 255, default: 0\n#define TMC5161_X2_MASK                               0xFF0000 // MSLUTSEL // LUT segment 2 start\n#define TMC5161_X2_SHIFT                              16 // min.: 0, max.: 255, default: 0\n#define TMC5161_X3_MASK                               0xFF000000 // MSLUTSEL // LUT segment 3 start\n#define TMC5161_X3_SHIFT                              24 // min.: 0, max.: 255, default: 0\n#define TMC5161_START_SIN_MASK                        0xFF // MSLUTSTART // Absolute current at microstep table entry 0.\n#define TMC5161_START_SIN_SHIFT                       0 // min.: 0, max.: 255, default: 0\n#define TMC5161_START_SIN90_MASK                      0xFF0000 // MSLUTSTART // Absolute current for microstep table entry at positions 256.\n#define TMC5161_START_SIN90_SHIFT                     16 // min.: 0, max.: 255, default: 0\n#define TMC5161_MSCNT_MASK                            0x03FF // MSCNT // Microstep counter. Indicates actual position in the microstep table for CUR_A. CUR_B uses an offset of 256 (2 phase motor). Hint: Move to a position where MSCNT is zero before re-initializing MSLUTSTART or MSLUT and MSLUTSEL.\n#define TMC5161_MSCNT_SHIFT                           0 // min.: 0, max.: 1023, default: 0\n#define TMC5161_CUR_A_MASK                            0x01FF // MSCURACT // Actual microstep current for motor phase A as read from MSLUT (not scaled by current)\n#define TMC5161_CUR_A_SHIFT                           0 // min.: -256, max.: 255, default: 0\n#define TMC5161_CUR_B_MASK                            0x01FF0000 // MSCURACT // Actual microstep current for motor phase B as read from MSLUT (not scaled by current)\n#define TMC5161_CUR_B_SHIFT                           16 // min.: -256, max.: 255, default: 0\n#define TMC5161_TOFF_MASK                             0x0F // CHOPCONF // off time and driver enable\n#define TMC5161_TOFF_SHIFT                            0 // min.: 0, max.: 15, default: 0\n#define TMC5161_TFD_ALL_MASK                          0x70 // CHOPCONF // fast decay time setting\n#define TMC5161_TFD_ALL_SHIFT                         4 // min.: 0, max.: 7, default: 0\n#define TMC5161_OFFSET_MASK                           0x0780 // CHOPCONF // sine wave offset\n#define TMC5161_OFFSET_SHIFT                          7 // min.: 0, max.: 15, default: 0\n#define TMC5161_TFD_3_MASK                            0x0800 // CHOPCONF // MSB of fast decay time setting\n#define TMC5161_TFD_3_SHIFT                           11 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISFDCC_MASK                          0x1000 // CHOPCONF // fast decay mode\n#define TMC5161_DISFDCC_SHIFT                         12 // min.: 0, max.: 1, default: 0\n#define TMC5161_CHM_MASK                              0x4000 // CHOPCONF // chopper mode\n#define TMC5161_CHM_SHIFT                             14 // min.: 0, max.: 1, default: 0\n#define TMC5161_TBL_MASK                              0x018000 // CHOPCONF // blank time select\n#define TMC5161_TBL_SHIFT                             15 // min.: 0, max.: 3, default: 0\n#define TMC5161_VHIGHFS_MASK                          0x040000 // CHOPCONF // high velocity fullstep selection\n#define TMC5161_VHIGHFS_SHIFT                         18 // min.: 0, max.: 1, default: 0\n#define TMC5161_VHIGHCHM_MASK                         0x080000 // CHOPCONF // high velocity chopper mode\n#define TMC5161_VHIGHCHM_SHIFT                        19 // min.: 0, max.: 1, default: 0\n#define TMC5161_TPFD_MASK                             0xF00000 // CHOPCONF // Passive fast decay time TPFD allows dampening of motor mid-range resonances. Passive fast decay time setting controls duration of the fast decay phase inserted after bridge polarity change N CLK = 12 + 256*TPFD %0000: Disable %0001 ... %1111: 1 ... 15\n#define TMC5161_TPFD_SHIFT                            20 // min.: 0, max.: 15, default: 0\n#define TMC5161_MRES_MASK                             0x0F000000 // CHOPCONF // Micro step resolution; The resolution gives the number of microstep entries per sine quarter wave. The driver automatically uses microstep positions which result in a symmetrical wave, when choosing a lower microstep resolution.\n#define TMC5161_MRES_SHIFT                            24 // min.: 0, max.: 8, default: 0\n#define TMC5161_INTPOL_MASK                           0x10000000 // CHOPCONF // interpolation to 256 microsteps\n#define TMC5161_INTPOL_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_DEDGE_MASK                            0x20000000 // CHOPCONF // enable double edge step pulses\n#define TMC5161_DEDGE_SHIFT                           29 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISS2G_MASK                           0x40000000 // CHOPCONF // short to GND protection disable\n#define TMC5161_DISS2G_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISS2VS_MASK                          0x80000000 // CHOPCONF // short to supply protection disable\n#define TMC5161_DISS2VS_SHIFT                         31 // min.: 0, max.: 1, default: 0\n#define TMC5161_TOFF_MASK                             0x0F // CHOPCONF // off time and driver enable\n#define TMC5161_TOFF_SHIFT                            0 // min.: 0, max.: 15, default: 0\n#define TMC5161_TFD_ALL_MASK                          0x70 // CHOPCONF // fast decay time setting\n#define TMC5161_TFD_ALL_SHIFT                         4 // min.: 0, max.: 7, default: 0\n#define TMC5161_OFFSET_MASK                           0x0780 // CHOPCONF // sine wave offset\n#define TMC5161_OFFSET_SHIFT                          7 // min.: 0, max.: 15, default: 0\n#define TMC5161_TFD_3_MASK                            0x0800 // CHOPCONF // MSB of fast decay time setting\n#define TMC5161_TFD_3_SHIFT                           11 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISFDCC_MASK                          0x1000 // CHOPCONF // fast decay mode\n#define TMC5161_DISFDCC_SHIFT                         12 // min.: 0, max.: 1, default: 0\n#define TMC5161_RNDTF_MASK                            0x2000 // CHOPCONF // random TOFF time\n#define TMC5161_RNDTF_SHIFT                           13 // min.: 0, max.: 1, default: 0\n#define TMC5161_CHM_MASK                              0x4000 // CHOPCONF // chopper mode\n#define TMC5161_CHM_SHIFT                             14 // min.: 0, max.: 1, default: 0\n#define TMC5161_TBL_MASK                              0x018000 // CHOPCONF // blank time select\n#define TMC5161_TBL_SHIFT                             15 // min.: 0, max.: 3, default: 0\n#define TMC5161_VSENSE_MASK                           0x020000 // CHOPCONF // sense resistor voltage based current scaling\n#define TMC5161_VSENSE_SHIFT                          17 // min.: 0, max.: 1, default: 0\n#define TMC5161_VHIGHFS_MASK                          0x040000 // CHOPCONF // high velocity fullstep selection\n#define TMC5161_VHIGHFS_SHIFT                         18 // min.: 0, max.: 1, default: 0\n#define TMC5161_VHIGHCHM_MASK                         0x080000 // CHOPCONF // high velocity chopper mode\n#define TMC5161_VHIGHCHM_SHIFT                        19 // min.: 0, max.: 1, default: 0\n#define TMC5161_TPFD_MASK                             0xF00000 // CHOPCONF // Passive fast decay time TPFD allows dampening of motor mid-range resonances. Passive fast decay time setting controls duration of the fast decay phase inserted after bridge polarity change N CLK = 12 + 256*TPFD %0000: Disable %0001 ... %1111: 1 ... 15\n#define TMC5161_TPFD_SHIFT                            20 // min.: 0, max.: 15, default: 0\n#define TMC5161_MRES_MASK                             0x0F000000 // CHOPCONF // Micro step resolution; The resolution gives the number of microstep entries per sine quarter wave. The driver automatically uses microstep positions which result in a symmetrical wave, when choosing a lower microstep resolution.\n#define TMC5161_MRES_SHIFT                            24 // min.: 0, max.: 8, default: 0\n#define TMC5161_INTPOL_MASK                           0x10000000 // CHOPCONF // interpolation to 256 microsteps\n#define TMC5161_INTPOL_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_DEDGE_MASK                            0x20000000 // CHOPCONF // enable double edge step pulses\n#define TMC5161_DEDGE_SHIFT                           29 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISS2G_MASK                           0x40000000 // CHOPCONF // short to GND protection disable\n#define TMC5161_DISS2G_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISS2VS_MASK                          0x80000000 // CHOPCONF // short to supply protection disable\n#define TMC5161_DISS2VS_SHIFT                         31 // min.: 0, max.: 1, default: 0\n#define TMC5161_TOFF_MASK                             0x0F // CHOPCONF // off time and driver enable\n#define TMC5161_TOFF_SHIFT                            0 // min.: 0, max.: 15, default: 0\n#define TMC5161_HSTRT_MASK                            0x70 // CHOPCONF // hysteresis start value added to HEND; Attention: Effective HEND+HSTRT less than or equal to 16. Hint: Hysteresis decrement is done each 16 clocks\n#define TMC5161_HSTRT_SHIFT                           4 // min.: 0, max.: 7, default: 0\n#define TMC5161_HEND_MASK                             0x0780 // CHOPCONF // hysteresis low value\n#define TMC5161_HEND_SHIFT                            7 // min.: 0, max.: 15, default: 0\n#define TMC5161_CHM_MASK                              0x4000 // CHOPCONF // chopper mode\n#define TMC5161_CHM_SHIFT                             14 // min.: 0, max.: 1, default: 0\n#define TMC5161_TBL_MASK                              0x018000 // CHOPCONF // blank time select\n#define TMC5161_TBL_SHIFT                             15 // min.: 0, max.: 3, default: 0\n#define TMC5161_VHIGHFS_MASK                          0x040000 // CHOPCONF // high velocity fullstep selection\n#define TMC5161_VHIGHFS_SHIFT                         18 // min.: 0, max.: 1, default: 0\n#define TMC5161_VHIGHCHM_MASK                         0x080000 // CHOPCONF // high velocity chopper mode\n#define TMC5161_VHIGHCHM_SHIFT                        19 // min.: 0, max.: 1, default: 0\n#define TMC5161_TPFD_MASK                             0xF00000 // CHOPCONF // Passive fast decay time TPFD allows dampening of motor mid-range resonances. Passive fast decay time setting controls duration of the fast decay phase inserted after bridge polarity change N CLK = 12 + 256*TPFD %0000: Disable %0001 ... %1111: 1 ... 15\n#define TMC5161_TPFD_SHIFT                            20 // min.: 0, max.: 15, default: 0\n#define TMC5161_MRES_MASK                             0x0F000000 // CHOPCONF // Micro step resolution; The resolution gives the number of microstep entries per sine quarter wave. The driver automatically uses microstep positions which result in a symmetrical wave, when choosing a lower microstep resolution.\n#define TMC5161_MRES_SHIFT                            24 // min.: 0, max.: 8, default: 0\n#define TMC5161_INTPOL_MASK                           0x10000000 // CHOPCONF // interpolation to 256 microsteps\n#define TMC5161_INTPOL_SHIFT                          28 // min.: 0, max.: 1, default: 0\n#define TMC5161_DEDGE_MASK                            0x20000000 // CHOPCONF // enable double edge step pulses\n#define TMC5161_DEDGE_SHIFT                           29 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISS2G_MASK                           0x40000000 // CHOPCONF // short to GND protection disable\n#define TMC5161_DISS2G_SHIFT                          30 // min.: 0, max.: 1, default: 0\n#define TMC5161_DISS2VS_MASK                          0x80000000 // CHOPCONF // short to supply protection disable\n#define TMC5161_DISS2VS_SHIFT                         31 // min.: 0, max.: 1, default: 0\n#define TMC5161_SEMIN_MASK                            0x0F // COOLCONF // minimum stallGuard2 value - If the stallGuard2 result falls below SEMIN*32, the motor current becomes increased to reduce motor load angle. 0: smart current control coolStep off\n#define TMC5161_SEMIN_SHIFT                           0 // min.: 0, max.: 15, default: 0\n#define TMC5161_SEUP_MASK                             0x60 // COOLCONF // Current increment steps per measured stallGuard2 value\n#define TMC5161_SEUP_SHIFT                            5 // min.: 0, max.: 3, default: 0\n#define TMC5161_SEMAX_MASK                            0x0F00 // COOLCONF // stallGuard2 hysteresis value - If the stallGuard2 result is equal to or above (SEMIN+SEMAX+1)*32, the motor current becomes decreased to save energy.\n#define TMC5161_SEMAX_SHIFT                           8 // min.: 0, max.: 15, default: 0\n#define TMC5161_SEDN_MASK                             0x6000 // COOLCONF // Current down step speed; For each n stallGuard2 values decrease by one\n#define TMC5161_SEDN_SHIFT                            13 // min.: 0, max.: 3, default: 0\n#define TMC5161_SEIMIN_MASK                           0x8000 // COOLCONF // minimum current for smart current control\n#define TMC5161_SEIMIN_SHIFT                          15 // min.: 0, max.: 1, default: 0\n#define TMC5161_SGT_MASK                              0x7F0000 // COOLCONF // stallGuard2 threshold value This signed value controls stallGuard2 level for stall output and sets the optimum measurement range for readout. A lower value gives a higher sensitivity. Zero is the starting value working with most motors. A higher value makes stallGuard2 less sensitive and requires more torque to indicate a stall.\n#define TMC5161_SGT_SHIFT                             16 // min.: -64, max.: 63, default: 0\n#define TMC5161_SFILT_MASK                            0x01000000 // COOLCONF // stallGuard2 filter enable\n#define TMC5161_SFILT_SHIFT                           24 // min.: 0, max.: 1, default: 0\n#define TMC5161_DC_TIME_MASK                          0x03FF // DCCTRL // Upper PWM on time limit for commutation (DC_TIME * 1/f CLK ). Set slightly above effective blank time TBL.\n#define TMC5161_DC_TIME_SHIFT                         0 // min.: 0, max.: 1023, default: 0\n#define TMC5161_DC_SG_MASK                            0xFF0000 // DCCTRL // Max. PWM on time for step loss detection using dcStep stallGuard2 in dcStep mode. (DC_SG * 16/f CLK); Set slightly higher than DC_TIME/16; 0=disable\n#define TMC5161_DC_SG_SHIFT                           16 // min.: 0, max.: 255, default: 0\n#define TMC5161_SG_RESULT_MASK                        0x03FF // DRV_STATUS // Mechanical load measurement: The stallGuard2 result gives a means to measure mechanical motor load. A higher value means lower mechanical load. A value of 0 signals highest load. With optimum SGT setting, this is an indicator for a motor stall. The stall detection compares SG_RESULT to 0 in order to detect a stall. SG_RESULT is used as a base for coolStep operation, by comparing it to a programmable upper and a lower limit. It is not applicable in stealthChop mode. SG_RESULT is ALSO applicable when dcStep is active. stallGuard2 works best with microstep operation. Temperature measurement: In standstill, no stallGuard2 result can be obtained. SG_RESULT shows the chopper on-time for motor coil A instead. If the motor is moved to a determined microstep position at a certain current setting, a comparison of the chopper on-time can help to get a rough estimation of motor temperature. As the motor heats up, its coil resistance rises and the chopper on-time increases.\n#define TMC5161_SG_RESULT_SHIFT                       0 // min.: 0, max.: 1023, default: 0\n//#define //TMC5161__MASK                             0x1000 // DRV_STATUS // s2vsa\n//#define //TMC5161__SHIFT                            12 // min.: 0, max.: 1, default: 0\n//#define ////TMC5161__MASK                           0x2000 // DRV_STATUS // s2vsb\n//#define ////TMC5161__SHIFT                          13 // min.: 0, max.: 1, default: 0\n//#define //////TMC5161__MASK                         0x4000 // DRV_STATUS // stealth\n//#define //////TMC5161__SHIFT                        14 // min.: 0, max.: 1, default: 0\n#define TMC5161_FSACTIVE_MASK                         0x8000 // DRV_STATUS //\n#define TMC5161_FSACTIVE_SHIFT                        15 // min.: 0, max.: 1, default: 0\n#define TMC5161_CS_ACTUAL_MASK                        0x1F0000 // DRV_STATUS //\n#define TMC5161_CS_ACTUAL_SHIFT                       16 // min.: 0, max.: 31, default: 0\n#define TMC5161_STALLGUARD_MASK                       0x01000000 // DRV_STATUS //\n#define TMC5161_STALLGUARD_SHIFT                      24 // min.: 0, max.: 1, default: 0\n#define TMC5161_OT_MASK                               0x02000000 // DRV_STATUS //\n#define TMC5161_OT_SHIFT                              25 // min.: 0, max.: 1, default: 0\n#define TMC5161_OTPW_MASK                             0x04000000 // DRV_STATUS //\n#define TMC5161_OTPW_SHIFT                            26 // min.: 0, max.: 1, default: 0\n#define TMC5161_S2GA_MASK                             0x08000000 // DRV_STATUS //\n#define TMC5161_S2GA_SHIFT                            27 // min.: 0, max.: 1, default: 0\n#define TMC5161_S2GB_MASK                             0x10000000 // DRV_STATUS //\n#define TMC5161_S2GB_SHIFT                            28 // min.: 0, max.: 1, default: 0\n#define TMC5161_OLA_MASK                              0x20000000 // DRV_STATUS //\n#define TMC5161_OLA_SHIFT                             29 // min.: 0, max.: 1, default: 0\n#define TMC5161_OLB_MASK                              0x40000000 // DRV_STATUS //\n#define TMC5161_OLB_SHIFT                             30 // min.: 0, max.: 1, default: 0\n#define TMC5161_STST_MASK                             0x80000000 // DRV_STATUS //\n#define TMC5161_STST_SHIFT                            31 // min.: 0, max.: 1, default: 0\n#define TMC5161_PWM_OFS_MASK                          0xFF // PWMCONF // User defined PWM amplitude offset (0-255) related to full motor current (CS_ACTUAL=31) in stand still. (Reset default=30) When  using  automatic  scaling  (pwm_autoscale=1)  the value  is  used  for  initialization,  only.  The  autoscale function  starts  with  PWM_SCALE_AUTO=PWM_OFS  and finds  the  required  offset  to  yield  the  target  current automatically. PWM_OFS  =  0  will  disable  scaling  down  motor  current below  a  motor  specific  lower  measurement  threshold. This  setting  should  only  be  used  under  certain conditions, i.e.  when the power supply voltage can vary up  and  down  by  a  factor  of  two  or  more.  It  prevents the  motor  going  out  of  regulation,  but  it  also  prevents power down below the regulation limit. PWM_OFS > 0 allows automatic scaling to low PWM duty cycles  even  below  the  lower  regulation  threshold.  This allows  low  (standstill)  current  settings  based  on  the actual (hold) current scale (register IHOLD_IRUN).\n#define TMC5161_PWM_OFS_SHIFT                         0 // min.: 0, max.: 255, default: 0\n#define TMC5161_PWM_GRAD_MASK                         0xFF00 // PWMCONF // Velocity dependent gradient for PWM amplitude: PWM_GRAD * 256 / TSTEP This  value  is  added  to  PWM_AMPL  to  compensate  for the velocity-dependent motor back-EMF. With  automatic  scaling  (pwm_autoscale=1)  the  value  is used  for  first  initialization,  only.  Set  PWM_GRAD  to  the application  specific  value  (it  can  be  read  out  from PWM_GRAD_AUTO)  to  speed  up  the  automatic  tuning process.  An  approximate  value can be stored to  OTP  by programming OTP_PWM_GRAD.\n#define TMC5161_PWM_GRAD_SHIFT                        8 // min.: 0, max.: 255, default: 0\n#define TMC5161_PWM_FREQ_MASK                         0x030000 // PWMCONF // %00:   fPWM=2/1024 fCLK          %01:   fPWM=2/683 fCLK          %10:   fPWM=2/512 fCLK          %11:   fPWM=2/410 fCLK\n#define TMC5161_PWM_FREQ_SHIFT                        16 // min.: 0, max.: 3, default: 0\n#define TMC5161_PWM_AUTOSCALE_MASK                    0x040000 // PWMCONF //\n#define TMC5161_PWM_AUTOSCALE_SHIFT                   18 // min.: 0, max.: 1, default: 0\n#define TMC5161_PWM_AUTOGRAD_MASK                     0x080000 // PWMCONF //\n#define TMC5161_PWM_AUTOGRAD_SHIFT                    19 // min.: 0, max.: 1, default: 0\n#define TMC5161_FREEWHEEL_MASK                        0x300000 // PWMCONF // Stand still option when motor current setting is zero (I_HOLD=0). %00:   Normal operation %01:   Freewheeling %10:   Coil shorted using LS drivers %11:   Coil shorted using HS drivers\n#define TMC5161_FREEWHEEL_SHIFT                       20 // min.: 0, max.: 3, default: 0\n#define TMC5161_PWM_REG_MASK                          0x0F000000 // PWMCONF // User defined  maximum  PWM amplitude  change per  half wave when using pwm_autoscale=1. (1...15): 1: 0.5 increments (slowest regulation) 2: 1 increment (default with OTP2.1=1) 3: 1.5 increments 4: 2 increments ... 8: 4 increments (default with OTP2.1=0) ... 15: 7.5 increments (fastest regulation)\n#define TMC5161_PWM_REG_SHIFT                         24 // min.: 0, max.: 15, default: 0\n#define TMC5161_PWM_LIM_MASK                          0xF0000000 // PWMCONF // Limit  for  PWM_SCALE_AUTO  when  switching  back  from spreadCycle to stealthChop. This value defines  the upper limit  for  bits  7  to  4  of  the  automatic  current  control when switching back. It can be set to reduce the current jerk during mode change back to stealthChop. It does not limit PWM_GRAD or PWM_GRAD_AUTO offset. (Default = 12)\n#define TMC5161_PWM_LIM_SHIFT                         28 // min.: 0, max.: 15, default: 0\n#define TMC5161_PWM_SCALE_SUM_MASK                    0xFF // PWM_SCALE // Actual PWM amplitude scaler (255=max. Voltage) In voltage mode PWM, this value allows to detect a motor stall.\n#define TMC5161_PWM_SCALE_SUM_SHIFT                   0 // min.: 0, max.: 255, default: 0\n#define TMC5161_PWM_SCALE_AUTO_MASK                   0x01FF0000 // PWM_SCALE // 9 Bit signed offset added to the calculated PWM duty cycle. This is the result of the automatic amplitude regulation based on current measurement.\n#define TMC5161_PWM_SCALE_AUTO_SHIFT                  16 // min.: -255, max.: 255, default: 0\n#define TMC5161_PWM_OFS_AUTO_MASK                     0xFF // PWM_AUTO // Automatically determined offset value\n#define TMC5161_PWM_OFS_AUTO_SHIFT                    0 // min.: 0, max.: 255, default: 0\n#define TMC5161_PWM_GRAD_AUTO_MASK                    0xFF0000 // PWM_AUTO // Automatically determined offset value\n#define TMC5161_PWM_GRAD_AUTO_SHIFT                   16 // min.: 0, max.: 255, default: 0\n#define TMC5161_LOST_STEPS_MASK                       0x0FFFFF // LOST_STEPS // Number of input steps skipped due to higher load in dcStep operation, if step input does not stop when DC_OUT is low. This counter wraps around after 2^20 steps. Counts up or down depending on direction.\n#define TMC5161_LOST_STEPS_SHIFT                      0 // min.: 0, max.: 1048575, default: 0\n\n#endif /* TMC5161_FIELDS_H */\n",
        "TMC5161_Register.h": "/*\n* TMC5161_Register.h\n*\n*  Created on: 13.06.2018\n*      Author: LK\n*/\n\n#ifndef TMC5161_REGISTER_H\n#define TMC5161_REGISTER_H\n\n// ===== TMC5161 register set =====\n\n#define TMC5161_GCONF          0x00\n#define TMC5161_GSTAT          0x01\n#define TMC5161_IFCNT          0x02\n#define TMC5161_SLAVECONF      0x03\n#define TMC5161_INP_OUT        0x04\n#define TMC5161_X_COMPARE      0x05\n#define TMC5161_OTP_PROG       0x06\n#define TMC5161_OTP_READ       0x07\n#define TMC5161_FACTORY_CONF   0x08\n#define TMC5161_SHORT_CONF     0x09\n#define TMC5161_DRV_CONF       0x0A\n#define TMC5161_GLOBAL_SCALER  0x0B\n#define TMC5161_OFFSET_READ    0x0C\n#define TMC5161_IHOLD_IRUN     0x10\n#define TMC5161_TPOWERDOWN     0x11\n#define TMC5161_TSTEP          0x12\n#define TMC5161_TPWMTHRS       0x13\n#define TMC5161_TCOOLTHRS      0x14\n#define TMC5161_THIGH          0x15\n\n#define TMC5161_RAMPMODE       0x20\n#define TMC5161_XACTUAL        0x21\n#define TMC5161_VACTUAL        0x22\n#define TMC5161_VSTART         0x23\n#define TMC5161_A1             0x24\n#define TMC5161_V1             0x25\n#define TMC5161_AMAX           0x26\n#define TMC5161_VMAX           0x27\n#define TMC5161_DMAX           0x28\n#define TMC5161_D1             0x2A\n#define TMC5161_VSTOP          0x2B\n#define TMC5161_TZEROWAIT      0x2C\n#define TMC5161_XTARGET        0x2D\n\n#define TMC5161_VDCMIN         0x33\n#define TMC5161_SWMODE         0x34\n#define TMC5161_RAMPSTAT       0x35\n#define TMC5161_XLATCH         0x36\n#define TMC5161_ENCMODE        0x38\n#define TMC5161_XENC           0x39\n#define TMC5161_ENC_CONST      0x3A\n#define TMC5161_ENC_STATUS     0x3B\n#define TMC5161_ENC_LATCH      0x3C\n#define TMC5161_ENC_DEVIATION  0x3D\n\n#define TMC5161_MSLUT0         0x60\n#define TMC5161_MSLUT1         0x61\n#define TMC5161_MSLUT2         0x62\n#define TMC5161_MSLUT3         0x63\n#define TMC5161_MSLUT4         0x64\n#define TMC5161_MSLUT5         0x65\n#define TMC5161_MSLUT6         0x66\n#define TMC5161_MSLUT7         0x67\n#define TMC5161_MSLUTSEL       0x68\n#define TMC5161_MSLUTSTART     0x69\n#define TMC5161_MSCNT          0x6A\n#define TMC5161_MSCURACT       0x6B\n#define TMC5161_CHOPCONF       0x6C\n#define TMC5161_COOLCONF       0x6D\n#define TMC5161_DCCTRL         0x6E\n#define TMC5161_DRVSTATUS      0x6F\n#define TMC5161_PWMCONF        0x70\n#define TMC5161_PWMSCALE       0x71\n#define TMC5161_PWM_AUTO       0x72\n#define TMC5161_LOST_STEPS     0x73\n\n#endif /* TMC5161_REGISTER_H */\n",
        "Types.h": "/*\n * Types.h\n *\n *  Created on: 29.09.2016\n *      Author: ed\n */\n\n#ifndef TMC_TYPES_H_\n#define TMC_TYPES_H_\n\n#include <stddef.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifndef TMC_TYPES_INTEGERS\n#define TMC_TYPES_INTEGERS\n\n// todo: change to standard ISO C99 types (ED)\n\n// www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\n// ISO C99: 7.18 Integer types 8, 16, 32, or 64 bits\n// intN_t = two’s complement signed integer type with width N, no padding bits.\n// uintN_t = an unsigned integer type with width N.\n// floatN_t = N bit IEE 754 float.\n// INT8_MIN, INT8_MAX, INT16_MIN, INT16_MAX, INT32_MIN, INT32_MAX, .... UINT32_MAX\n\ntypedef float float32_t;\ntypedef double float64_t;\n\n#ifndef TMC_TYPES_INTEGERS_UNSIGNED\n#define TMC_TYPES_INTEGERS_UNSIGNED\n\ntypedef uint8_t  u8;\ntypedef uint16_t u16;\ntypedef uint32_t u32;\n\ntypedef uint8_t       uint8;\ntypedef uint16_t      uint16;\ntypedef uint32_t      uint32;\n\n#define u8_MAX   (uint8_t)   255\n#define u10_MAX  (uint16_t)  1023\n#define u12_MAX  (uint16_t)  4095\n#define u15_MAX  (uint16_t)  32767\n#define u16_MAX  (uint16_t)  65535\n#define u18_MAX  (uint32_t)  262143uL\n#define u20_MAX  (uint32_t)  1048575uL\n#define u22_MAX  (uint32_t)  4194303uL\n#define u24_MAX  (uint32_t)  16777215uL\n#define u32_MAX  (uint32_t)  4294967295uL\n\n#endif\n\n#ifndef TMC_TYPES_INTEGERS_SIGNED\n#define TMC_TYPES_INTEGERS_SIGNED\n\ntypedef int8_t   s8;\ntypedef int16_t  s16;\ntypedef int32_t  s32;\n\ntypedef int8_t       int8;\ntypedef int16_t      int16;\ntypedef int32_t      int32;\n\n#define s8_MAX   (int8_t)   127\n#define s8_MIN   (int8_t)   -128\n#define s16_MAX  (int16_t)  32767\n#define s16_MIN  (int16_t)  -32768\n#define s24_MAX  (int32_t)  8388607\n#define s24_MIN  (int32_t)  -8388608\n#define s32_MAX  (int32_t)  2147483647\n#define s32_MIN  (int32_t)  -2147483648\n\n#endif\n\n#endif\n\n#ifndef TMC_TYPES_NULL\n#define TMC_TYPES_NULL\n\n#ifndef NULL\n#define NULL ((void *) 0)\n#endif\n\n#endif\n\n#endif /* TMC_TYPES_H_ */\n",
        "atmo_tmc5161.h": "#ifndef __ATMO_TMC5161_H_\n#define __ATMO_TMC5161_H_\n\n/******************************************************************************/\n/*                                Includes                                    */\n/******************************************************************************/\n#include \"../app_src/atmosphere_platform.h\"\n#include \"../include/spi_basic.h\"\n\n#include \"TMC5161.h\"\n\n/******************************************************************************/\n/*                                 Defines                                    */\n/******************************************************************************/\n\n\n/******************************************************************************/\n/*                       Structs, Typedefs, and Enums                         */\n/******************************************************************************/\ntypedef struct\n{\n\tATMO_DriverInstanceHandle_t gpioDriverInstance;\n\tuint32_t cs_pin;\n\tuint32_t vmax;\n\tint8_t dir;\n} ATMO_TMC5161_Config_t;\n\n\ntypedef enum\n{\n\tATMO_TMC5161_Status_Success = 0,\n\tATMO_TMC5161_Status_Fail,\n} ATMO_TMC5161_Status_t;\n\n\n/******************************************************************************/\n/*                       Public Function Declarations                         */\n/******************************************************************************/\nvoid tmc5161_readWriteArray(uint8_t channel, uint8_t *data, size_t length);\nATMO_TMC5161_Status_t ATMO_TMC5161_Init(ATMO_DriverInstanceHandle_t *handle, ATMO_TMC5161_Config_t *config);\nATMO_TMC5161_Status_t ATMO_TMC5161_SetVelocity(ATMO_DriverInstanceHandle_t handle, uint8_t velocity);\nATMO_TMC5161_Status_t ATMO_TMC5161_SetAcceleration(ATMO_DriverInstanceHandle_t handle, uint8_t acceleration);\nATMO_TMC5161_Status_t ATMO_TMC5161_MoveTo(ATMO_DriverInstanceHandle_t handle, uint8_t position);\nATMO_TMC5161_Status_t ATMO_TMC5161_SetDirection(ATMO_DriverInstanceHandle_t handle, ATMO_BOOL_t direction);\nATMO_TMC5161_Status_t ATMO_TMC5161_Stop(ATMO_DriverInstanceHandle_t handle);\n\n#endif\n"
      },
      "objects": {
        "CRC.c": "/*\n * CRC.c\n *\n *  Created on: 04.12.2017\n *      Author: LH\n *\n *  This is a generic implementation for a CRC8 generator supporting\n *  both compile-time (1) and run-time initialized Lookup tables for efficient CRC8 calculation.\n *  You can store multiple tables for different polynomials and (non-)reflected CRCs.\n *  The different tables are referenced by an index, with an upper limit set at compile time (CRC_TABLE_COUNT).\n *\n *  To generate CRCs you must first generate the Lookup-table by calling fillCRCTable()\n *  with any index. CRCs can then be generated from any data buffer by calling CRC()\n *  with the same index previously given to fillCRCTable().\n *\n *  The table generation has been optimized for speed so that the runtime\n *  table generation can even be done during normal operation if required.\n *  However, as long as the required polynomials are known on initialization,\n *  the table generation should be done at that time.\n *  On the Landungsbruecke the initialization of a CRC table takes ~250µs. (2)\n *  Should your application still have problems with the table calculation time,\n *  this algorithm could probably be speed up by preparing a 2- or 4-bit lookup table\n *  to speed up the actual table generation.\n *\n *  (1): For compile-time CRC tables, just fill the table(s) by initializing CRCTables[] to the proper values.\n *  (2): Tested by toggling a GPIO pin, generating a table in-between and measuring the GPIO pulse width.\n */\n\n#include \"CRC.h\"\n\ntypedef struct {\n\tuint8_t table[256];\n\tuint8_t polynomial;\n\tbool isReflected;\n} CRCTypeDef;\n\nCRCTypeDef CRCTables[CRC_TABLE_COUNT] = { 0 };\n\nstatic uint8_t flipByte(uint8_t value);\nstatic uint32_t flipBitsInBytes(uint32_t value);\n\n/* This function generates the Lookup table used for CRC calculations.\n *\n * Arguments:\n *     uint8_t polynomial: The CRC polynomial for which the table will be generated.\n *     bool isReflected: Indicator whether the CRC table will be reflected or not.\n *     uint8_t index: The index of the table to be filled.\n *\n * How it works:\n *     A CRC calculation of a byte can be done by taking the byte to be CRC'd,\n *     shifting it left by one (appending a 0) and - if a 1 has been shifted out -\n *     XOR-ing in the CRC polynomial. After 8 iterations the result will be the\n *     CRC of the Byte.\n *\n *     The function below does this in a compact way, by using all 4 bytes of a\n *     uint32_t to do 4 separate CRC bytes at once.\n *     For this to work without the Byte shifting interfering with adjacent bytes,\n *     the polynomial has the 8th bit (0x100) set. That way, if the shifted-out bit\n *     is 1, the following XOR-ing with the CRC polynomial will set that 1 to a 0,\n *     resulting in the shifted-in 0 for the adjacent byte.\n *     This process will go from the the lowest to the highest byte, resulting in\n *     fully independent byte-wise CRC calculations. For the highest byte, the value\n *     of the shifted-out byte needs to be stored before shifting the bytes (isMSBSet).\n *\n *     The for-loop that iterates over all uint8_t values starts out with the\n *     uint8_t values 3 to 0 stored in one uint32_t: 0x03020100\n *     for each iteration each uint8_t value will increase by 4..\n *     0 -> 4 -> 8 -> C -> ...\n *     1 -> 5 -> 9 -> D -> ...\n *     2 -> 6 -> A -> E -> ...\n *     3 -> 7 -> B -> F -> ...\n *     ..resulting in an increase of the uint32_t by 0x04040404:\n *     0x03020100 -> 0x07060504 -> 0x0B0A0908 -> 0x0F0E0D0C -> ...\n *     The loop ends as soon as we have iterated over all uint8_t values.\n *     We detect that by looking for the byte-wise overflow into the next byte:\n *     0xFFFEFDFC                  <- last uint32_t value to be calculated\n *     0xFF,  0xFE,  0xFD,  0xFC   <- the corresponding uint8_t values\n *     0x103, 0x102, 0x101, 0x100  <- incremented uint8_t values (overflow into the next byte!)\n *     0x04030200                  <- uint32_t value with the overflowed bytes\n *\n *     We have the lower uint8_t values at the lower bytes of the uint32_t.\n *     This allows us to simply store the lowest byte of the uint32_t,\n *     right-shift the uint32_t by 8 and increment the table pointer.\n *     After 4 iterations of that all 4 bytes of the uint32_t are stored in the table.\n */\nuint8_t tmc_fillCRC8Table(uint8_t polynomial, bool isReflected, uint8_t index)\n{\n\tuint32_t CRCdata;\n\t// Helper pointer for traversing the result table\n\tuint8_t *table;\n\n\tif(index >= CRC_TABLE_COUNT)\n\t\treturn 0;\n\n\tCRCTables[index].polynomial   = polynomial;\n\tCRCTables[index].isReflected  = isReflected;\n\ttable = &CRCTables[index].table[0];\n\n\t// Extend the polynomial to correct byte MSBs shifting into next bytes\n\tuint32_t poly = (uint32_t) polynomial | 0x0100;\n\n\t// Iterate over all 256 possible uint8_t values, compressed into a uint32_t (see detailed explanation above)\n\tuint32_t i;\n\tfor(i = 0x03020100; i != 0x04030200; i+=0x04040404)\n\t{\n\t\t// For reflected table: Flip the bits of each input byte\n\t\tCRCdata = (isReflected)? flipBitsInBytes(i) : i;\n\n\t\t// Iterate over 8 Bits\n\t\tint j;\n\t\tfor(j = 0; j < 8; j++)\n\t\t{\n\t\t\t// Store value of soon-to-be shifted out byte\n\t\t\tuint8_t isMSBSet = (CRCdata & 0x80000000)? 1:0;\n\n\t\t\t// CRC Shift\n\t\t\tCRCdata <<= 1;\n\n\t\t\t// XOR the bytes when required, lowest to highest\n\t\t\tCRCdata ^= (CRCdata & 0x00000100)? (poly      ) : 0;\n\t\t\tCRCdata ^= (CRCdata & 0x00010000)? (poly << 8 ) : 0;\n\t\t\tCRCdata ^= (CRCdata & 0x01000000)? (poly << 16) : 0;\n\t\t\tCRCdata ^= (isMSBSet)?             (poly << 24) : 0;\n\t\t}\n\n\t\t// For reflected table: Flip the bits of each output byte\n\t\tCRCdata = (isReflected)? flipBitsInBytes(CRCdata) : CRCdata;\n\t\t// Store the CRC result bytes in the table array\n\t\t*table++ = (uint8_t) CRCdata;\n\t\tCRCdata >>= 8;\n\t\t*table++ = (uint8_t) CRCdata;\n\t\tCRCdata >>= 8;\n\t\t*table++ = (uint8_t) CRCdata;\n\t\tCRCdata >>= 8;\n\t\t*table++ = (uint8_t) CRCdata;\n\t}\n\n\treturn 1;\n}\n\n/* This function calculates the CRC from a data buffer\n *\n * Arguments:\n *     uint8_t *data: A pointer to the data that will be CRC'd.\n *     uint32_t bytes: The length of the data buffer.\n *     uint8_t index: The index of the CRC table to be used.\n */\nuint8_t tmc_CRC8(uint8_t *data, uint32_t bytes, uint8_t index)\n{\n\tuint8_t result = 0;\n\tuint8_t *table;\n\n\tif(index >= CRC_TABLE_COUNT)\n\t\treturn 0;\n\n\ttable = &CRCTables[index].table[0];\n\n\twhile(bytes--)\n\t\tresult = table[result ^ *data++];\n\n\treturn (CRCTables[index].isReflected)? flipByte(result) : result;\n}\n\nuint8_t tmc_tableGetPolynomial(uint8_t index)\n{\n\tif(index >= CRC_TABLE_COUNT)\n\t\treturn 0;\n\n\treturn CRCTables[index].polynomial;\n}\n\nbool tmc_tableIsReflected(uint8_t index)\n{\n\tif(index >= CRC_TABLE_COUNT)\n\t\treturn false;\n\n\treturn CRCTables[index].isReflected;\n}\n\n// Helper functions\nstatic uint8_t flipByte(uint8_t value)\n{\n\t// swap odd and even bits\n\tvalue = ((value >> 1) & 0x55) | ((value & 0x55) << 1);\n\t// swap consecutive pairs\n\tvalue = ((value >> 2) & 0x33) | ((value & 0x33) << 2);\n\t// swap nibbles ...\n\tvalue = ((value >> 4) & 0x0F) | ((value & 0x0F) << 4);\n\n\treturn value;\n}\n\n/* This helper function switches all bits within each byte.\n * The byte order remains the same:\n * [b31 b30 b29 b28 b27 b26 b25 b24 .. b7 b6 b5 b4 b3 b2 b1 b0]\n *                                  ||\n *                                 \\||/\n *                                  \\/\n * [b24 b25 b26 b27 b28 b29 b30 b31 .. b0 b1 b2 b3 b4 b5 b6 b7]\n */\nstatic uint32_t flipBitsInBytes(uint32_t value)\n{\n\t// swap odd and even bits\n\tvalue = ((value >> 1) & 0x55555555) | ((value & 0x55555555) << 1);\n\t// swap consecutive pairs\n\tvalue = ((value >> 2) & 0x33333333) | ((value & 0x33333333) << 2);\n\t// swap nibbles ...\n\tvalue = ((value >> 4) & 0x0F0F0F0F) | ((value & 0x0F0F0F0F) << 4);\n\n\treturn value;\n}\n",
        "Functions.c": "/*\n * Functions.c\n *\n *  Created on: 23.07.2018\n *      Author: ed\n */\n#include \"Functions.h\"\n\nint32_t tmc_limitInt(int32_t value, int32_t min, int32_t max)\n{\n\tif (value > max)\n\t\treturn max;\n\telse if (value < min)\n\t\treturn min;\n\telse\n\t\treturn value;\n}\n\nint64_t tmc_limitS64(int64_t value, int64_t min, int64_t max)\n{\n\tif (value > max)\n\t\treturn max;\n\telse if (value < min)\n\t\treturn min;\n\telse\n\t\treturn value;\n}\n\n/* lookup table for square root function */\nstatic const unsigned char sqrttable[256] =\n{\n\t0,   16,  22,  27,  32,  35,  39,  42,  45,  48,  50,  53,  55,  57,  59,  61,\n\t64,  65,  67,  69,  71,  73,  75,  76,  78,  80,  81,  83,  84,  86,  87,  89,\n\t90,  91,  93,  94,  96,  97,  98,  99,  101, 102, 103, 104, 106, 107, 108, 109,\n\t110, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126,\n\t128, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142,\n\t143, 144, 144, 145, 146, 147, 148, 149, 150, 150, 151, 152, 153, 154, 155, 155,\n\t156, 157, 158, 159, 160, 160, 161, 162, 163, 163, 164, 165, 166, 167, 167, 168,\n\t169, 170, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 178, 179, 180,\n\t181, 181, 182, 183, 183, 184, 185, 185, 186, 187, 187, 188, 189, 189, 190, 191,\n\t192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201,\n\t202, 203, 203, 204, 204, 205, 206, 206, 207, 208, 208, 209, 209, 210, 211, 211,\n\t212, 212, 213, 214, 214, 215, 215, 216, 217, 217, 218, 218, 219, 219, 220, 221,\n\t221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227, 227, 228, 229, 229, 230,\n\t230, 231, 231, 232, 232, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238,\n\t239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247,\n\t247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254, 255\n};\n\nint32_t tmc_sqrti(int32_t x)\n{\n\tint32_t xn;\n\n\t// Negative parameter?\n\tif (x < 0)\n\t\treturn -1;\n\n\tif (x < 0x0100)\n\t\treturn (int) sqrttable[x] >> 4;\n\n\tif (x >= 0x00010000)\n\t{\n\t\tif (x >= 0x01000000)\n\t\t{\n\t\t\tif (x >= 0x10000000)\n\t\t\t{\n\t\t\t\tif (x >= 0x40000000)\n\t\t\t\t{\n\t\t\t\t\t// 0x40000000 <= x < 0x7FFFFFFF\n\t\t\t\t\txn = (int) sqrttable[x >> 24] << 8;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 0x10000000 <= x < 0x40000000\n\t\t\t\t\txn = (int) sqrttable[x >> 22] << 7;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (x >= 0x04000000)\n\t\t\t\t{\n\t\t\t\t\t// 0x04000000 <= x < 0x10000000\n\t\t\t\t\txn = (int) sqrttable[x >> 20] << 6;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 0x01000000 <= x < 0x04000000\n\t\t\t\t\txn = (int) sqrttable[x >> 18] << 5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Two steps of the babylonian method\n\t\t\txn = (xn + 1 + (x / xn)) >> 1;\n\t\t\txn = (xn + 1 + (x / xn)) >> 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (x >= 0x00100000)\n\t\t\t{\n\t\t\t\tif (x >= 0x00400000)\n\t\t\t\t{\n\t\t\t\t\t// 0x00400000 <= x < 0x01000000\n\t\t\t\t\txn = (int) sqrttable[x >> 16] << 4;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 0x00100000 <= x < 0x00400000\n\t\t\t\t\txn = (int) sqrttable[x >> 14] << 3;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (x >= 0x00040000)\n\t\t\t\t{\n\t\t\t\t\t// 0x00040000 <= x < 0x00100000\n\t\t\t\t\txn = (int) sqrttable[x >> 12] << 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// 0x00010000 <= x < 0x00040000\n\t\t\t\t\txn = (int) sqrttable[x >> 10] << 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// One step of the babylonian method\n\t\t\txn = (xn + 1 + (x / xn)) >> 1;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (x >= 0x1000)\n\t\t{\n\t\t\tif (x >= 0x4000)\n\t\t\t{\n\t\t\t\t// 0x4000 <= x < 0x00010000\n\t\t\t\txn = (int) (sqrttable[x >> 8] ) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 0x1000 <= x < 0x4000\n\t\t\t\txn = (int) (sqrttable[x >> 6] >> 1) + 1;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (x >= 0x0400)\n\t\t\t{\n\t\t\t\t// 0x0400 <= x < 0x1000\n\t\t\t\txn = (int) (sqrttable[x >> 4] >> 2) + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// 0x0100 <= x < 0x0400\n\t\t\t\txn = (int) (sqrttable[x >> 2] >> 3) + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Make sure that our result is floored\n\tif ((xn * xn) > x)\n\t\txn--;\n\n\treturn xn;\n}\n\nint32_t tmc_filterPT1(int64_t *akku, int32_t newValue, int32_t lastValue, uint8_t actualFilter, uint8_t maxFilter)\n{\n\t*akku += (newValue-lastValue) << (maxFilter-actualFilter);\n\treturn *akku >> maxFilter;\n}\n",
        "LinearRamp1.c": "/*\n * TMC_LinearRamp.c\n *\n *  Created on: 09.11.2018\n *      Author: LK\n */\n#include \"LinearRamp1.h\"\n#include \"Functions.h\"\n\nvoid tmc_ramp_linear_init(TMC_LinearRamp *linearRamp)\n{\n\tlinearRamp->maxVelocity         = 0;\n\tlinearRamp->targetPosition      = 0;\n\tlinearRamp->targetVelocity      = 0;\n\tlinearRamp->rampVelocity        = 0;\n\tlinearRamp->rampPosition        = 0;\n\tlinearRamp->acceleration        = 0;\n\tlinearRamp->rampEnabled         = true;\n\tlinearRamp->accumulatorVelocity = 0;\n\tlinearRamp->accumulatorPosition = 0;\n\tlinearRamp->rampMode            = TMC_RAMP_LINEAR_MODE_VELOCITY;\n\tlinearRamp->dx                  = 0;\n\tlinearRamp->state               = TMC_RAMP_LINEAR_STATE_IDLE;\n\tlinearRamp->homingDistance      = TMC_RAMP_LINEAR_HOMING_DISTANCE;\n\tlinearRamp->stopVelocity        = TMC_RAMP_LINEAR_STOP_VELOCITY;\n}\n\nvoid tmc_ramp_linear_set_enabled(TMC_LinearRamp *linearRamp, bool enabled)\n{\n\tlinearRamp->rampEnabled = enabled;\n}\n\nvoid tmc_ramp_linear_set_maxVelocity(TMC_LinearRamp *linearRamp, uint32_t maxVelocity)\n{\n\tlinearRamp->maxVelocity = maxVelocity;\n}\n\nvoid tmc_ramp_linear_set_targetPosition(TMC_LinearRamp *linearRamp, int32_t targetPosition)\n{\n\tlinearRamp->targetPosition = targetPosition;\n}\n\nvoid tmc_ramp_linear_set_rampPosition(TMC_LinearRamp *linearRamp, int32_t rampPosition)\n{\n\tlinearRamp->rampPosition = rampPosition;\n}\n\nvoid tmc_ramp_linear_set_targetVelocity(TMC_LinearRamp *linearRamp, int32_t targetVelocity)\n{\n\tlinearRamp->targetVelocity = targetVelocity;\n}\n\nvoid tmc_ramp_linear_set_rampVelocity(TMC_LinearRamp *linearRamp, int32_t rampVelocity)\n{\n\tlinearRamp->rampVelocity = rampVelocity;\n}\n\nvoid tmc_ramp_linear_set_acceleration(TMC_LinearRamp *linearRamp, int32_t acceleration)\n{\n\tlinearRamp->acceleration = acceleration;\n}\n\nvoid tmc_ramp_linear_set_mode(TMC_LinearRamp *linearRamp, TMC_LinearRamp_Mode mode)\n{\n\tlinearRamp->rampMode = mode;\n}\n\nvoid tmc_ramp_linear_set_homingDistance(TMC_LinearRamp *linearRamp, uint32_t homingDistance)\n{\n\tlinearRamp->homingDistance = homingDistance;\n}\n\nvoid tmc_ramp_linear_set_stopVelocity(TMC_LinearRamp *linearRamp, uint32_t stopVelocity)\n{\n\tlinearRamp->stopVelocity = stopVelocity;\n}\n\nbool tmc_ramp_linear_get_enabled(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->rampEnabled;\n}\n\nuint32_t tmc_ramp_linear_get_maxVelocity(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->maxVelocity;\n}\n\nint32_t tmc_ramp_linear_get_targetPosition(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->targetPosition;\n}\n\nint32_t tmc_ramp_linear_get_rampPosition(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->rampPosition;\n}\n\nint32_t tmc_ramp_linear_get_targetVelocity(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->targetVelocity;\n}\n\nint32_t tmc_ramp_linear_get_rampVelocity(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->rampVelocity;\n}\n\nint32_t tmc_ramp_linear_get_acceleration(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->acceleration;\n}\n\nint32_t tmc_ramp_linear_get_dx(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->dx;\n}\n\nTMC_LinearRamp_State tmc_ramp_linear_get_state(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->state;\n}\n\nTMC_LinearRamp_Mode tmc_ramp_linear_get_mode(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->rampMode;\n}\n\nuint32_t tmc_ramp_linear_get_homingDistance(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->homingDistance;\n}\n\nuint32_t tmc_ramp_linear_get_stopVelocity(TMC_LinearRamp *linearRamp)\n{\n\treturn linearRamp->stopVelocity;\n}\n\nvoid tmc_ramp_linear_reset_dx(TMC_LinearRamp *linearRamp)\n{\n\tlinearRamp->dx = 0;\n}\n\nvoid tmc_ramp_linear_compute(TMC_LinearRamp *linearRamp, uint32_t delta)\n{\n\ttmc_ramp_linear_compute_velocity(linearRamp, delta);\n\ttmc_ramp_linear_compute_position(linearRamp, delta);\n}\n\nvoid tmc_ramp_linear_compute_velocity(TMC_LinearRamp *linearRamp, uint32_t delta)\n{\n\tbool accelerating = linearRamp->rampVelocity != linearRamp->targetVelocity;\n\n\tif (linearRamp->rampEnabled)\n\t{\n\t\t// Add current acceleration to accumulator\n\t\tlinearRamp->accumulatorVelocity += linearRamp->acceleration * delta;\n\n\t\t// Emit the TMC_RAMP_LINEAR_ACCUMULATOR_DECIMALS decimal places and use the integer as dv\n\t\tint32_t dv = linearRamp->accumulatorVelocity >> TMC_RAMP_LINEAR_ACCUMULATOR_VELOCITY_DECIMALS;\n\n\t\t// Reset accumulator\n\t\tlinearRamp->accumulatorVelocity -= dv << TMC_RAMP_LINEAR_ACCUMULATOR_VELOCITY_DECIMALS;\n\n\t\t// Add dv to rampVelocity, and regulate to target velocity\n\t\tif(linearRamp->rampVelocity < linearRamp->targetVelocity)\n\t\t\tlinearRamp->rampVelocity = MIN(linearRamp->rampVelocity + dv, linearRamp->targetVelocity);\n\t\telse if(linearRamp->rampVelocity > linearRamp->targetVelocity)\n\t\t\tlinearRamp->rampVelocity = MAX(linearRamp->rampVelocity - dv, linearRamp->targetVelocity);\n\t}\n\telse\n\t{\n\t\t// use target velocity directly\n\t\tlinearRamp->rampVelocity = linearRamp->targetVelocity;\n\t\t// Reset accumulator\n\t\tlinearRamp->accumulatorVelocity = 0;\n\t}\n\n\t// Accumulate required position change by current velocity\n\tlinearRamp->accumulatorPosition += (linearRamp->rampVelocity * delta);\n\tlinearRamp->dx = linearRamp->accumulatorPosition >> TMC_RAMP_LINEAR_ACCUMULATOR_POSITION_DECIMALS;\n\tlinearRamp->accumulatorPosition -= linearRamp->dx << TMC_RAMP_LINEAR_ACCUMULATOR_POSITION_DECIMALS;\n\n\tif(linearRamp->dx == 0)\n\t\treturn;\n\n\t// Change actual position determined by position change and delta-time\n\tlinearRamp->rampPosition += (linearRamp->dx < 0) ? (-1) : (1);\n\t//linearRamp->rampPosition += (linearRamp->dx * delta);\n\n\t// Count acceleration steps needed for decelerating later\n\tlinearRamp->accelerationSteps += (abs(linearRamp->rampVelocity) < abs(linearRamp->targetVelocity)) ? accelerating : -accelerating;\n}\n\nvoid tmc_ramp_linear_compute_position(TMC_LinearRamp *linearRamp, uint32_t delta)\n{\n\tUNUSED(delta);\n\n\tif (!linearRamp->rampEnabled)\n\t\treturn;\n\n\tif (linearRamp->rampMode != TMC_RAMP_LINEAR_MODE_POSITION)\n\t\treturn;\n\n\t// Calculate steps needed to target\n\tint32_t diffx = 0;\n\n\tswitch(linearRamp->state) {\n\tcase TMC_RAMP_LINEAR_STATE_IDLE:\n\t\tif(linearRamp->rampVelocity == 0)\n\t\t\tlinearRamp->accelerationSteps = 0;\n\n\t\tif(linearRamp->rampPosition == linearRamp->targetPosition)\n\t\t\tbreak;\n\n\t\tlinearRamp->state = TMC_RAMP_LINEAR_STATE_DRIVING;\n\t\tbreak;\n\tcase TMC_RAMP_LINEAR_STATE_DRIVING:\n\t\t// Calculate distance to target (positive = driving towards target)\n\t\tif(linearRamp->rampVelocity > 0)\n\t\t\tdiffx = linearRamp->targetPosition - linearRamp->rampPosition;\n\t\telse if(linearRamp->rampVelocity < 0)\n\t\t\tdiffx = -(linearRamp->targetPosition - linearRamp->rampPosition);\n\t\telse\n\t\t\tdiffx = abs(linearRamp->targetPosition - linearRamp->rampPosition);\n\n\t\t// Steps left required for braking?\n\t\t// (+ 1 to compensate rounding (flooring) errors of the position accumulator)\n\t\tif(linearRamp->accelerationSteps + 1 >= diffx)\n\t\t{\n\t\t\tlinearRamp->targetVelocity = 0;\n\t\t\tlinearRamp->state = TMC_RAMP_LINEAR_STATE_BRAKING;\n\t\t}\n\t\telse\n\t\t{\t// Driving - apply VMAX (this also allows mid-ramp VMAX changes)\n\t\t\tlinearRamp->targetVelocity = (linearRamp->targetPosition > linearRamp->rampPosition) ? linearRamp->maxVelocity : -linearRamp->maxVelocity;\n\t\t}\n\t\tbreak;\n\tcase TMC_RAMP_LINEAR_STATE_BRAKING:\n\t\tif(linearRamp->targetPosition == linearRamp->rampPosition)\n\t\t{\n\t\t\tif(abs(linearRamp->rampVelocity) <= linearRamp->stopVelocity)\n\t\t\t{\t// Position reached, velocity within cutoff threshold (or zero)\n\t\t\t\tlinearRamp->rampVelocity = 0; // actualVelocity = 0;\n\t\t\t\tlinearRamp->targetVelocity = 0; // currCh->targetVelocity = 0;\n\t\t\t\tlinearRamp->state = TMC_RAMP_LINEAR_STATE_IDLE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// We're still too fast, we're going to miss the target position\n\t\t\t\t// Let the decceleration continue until velocity is zero, then either\n\t\t\t\t// home when within homing distance or start a new ramp (RAMP_DRIVING)\n\t\t\t\t// towards the target.\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(linearRamp->rampVelocity != 0)\n\t\t\t{\t// Still deccelerating\n\n\t\t\t\t// Calculate distance to target (positive = driving towards target)\n\t\t\t\tif(linearRamp->rampVelocity > 0)\n\t\t\t\t\tdiffx = linearRamp->targetPosition - linearRamp->rampPosition;\n\t\t\t\telse if(linearRamp->rampVelocity < 0)\n\t\t\t\t\tdiffx = -(linearRamp->targetPosition - linearRamp->rampPosition);\n\t\t\t\telse\n\t\t\t\t\tdiffx = abs(linearRamp->targetPosition - linearRamp->rampPosition);\n\n\t\t\t\t// Enough space to accelerate again?\n\t\t\t\t// (+ 1 to compensate rounding (flooring) errors of the position accumulator)\n\t\t\t\tif(linearRamp->accelerationSteps + 1 < diffx)\n\t\t\t\t{\n\t\t\t\t\tlinearRamp->state = TMC_RAMP_LINEAR_STATE_DRIVING;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(abs(linearRamp->targetPosition - linearRamp->rampPosition) <= linearRamp->homingDistance)\n\t\t\t{\t// Within homing distance - drive with V_STOP velocity\n\t\t\t\tlinearRamp->targetVelocity = (linearRamp->targetPosition > linearRamp->rampPosition)? linearRamp->stopVelocity : -linearRamp->stopVelocity;\n\t\t\t}\n\t\t\telse\n\t\t\t{\t// Not within homing distance - start a new motion by switching to RAMP_IDLE\n\t\t\t\t// Since (targetPosition != actualPosition) a new ramp will be started.\n\t\t\t\tlinearRamp->state = TMC_RAMP_LINEAR_STATE_IDLE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n}\n",
        "Ramp.c": "/*\n * Ramp.c\n *\n *  Created on: 09.11.2018\n *      Author: LK\n */\n\n#include \"Ramp.h\"\n\nvoid tmc_ramp_init(void *ramp, TMC_RampType type)\n{\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\tdefault:\n\t\ttmc_ramp_linear_init((TMC_LinearRamp *)ramp);\n\t\tbreak;\n\t}\n}\n\nvoid tmc_ramp_compute(void *ramp, TMC_RampType type, uint32_t delta)\n{\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\tdefault:\n\t\ttmc_ramp_linear_compute((TMC_LinearRamp *)ramp, delta);\n\t\tbreak;\n\t}\n}\n\nint32_t tmc_ramp_get_rampVelocity(void *ramp, TMC_RampType type)\n{\n\tint32_t v = 0;\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\t\tv = tmc_ramp_linear_get_rampVelocity((TMC_LinearRamp *)ramp);\n\t\tbreak;\n\t}\n\treturn v;\n}\n\nint32_t tmc_ramp_get_rampPosition(void *ramp, TMC_RampType type)\n{\n\tint32_t x = 0;\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\t\tx = tmc_ramp_linear_get_rampPosition((TMC_LinearRamp *)ramp);\n\t\tbreak;\n\t}\n\treturn x;\n}\n\nbool tmc_ramp_get_enabled(void *ramp, TMC_RampType type)\n{\n\tbool enabled = false;\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\t\tenabled = tmc_ramp_linear_get_enabled((TMC_LinearRamp *)ramp);\n\t\tbreak;\n\t}\n\treturn enabled;\n}\n\nvoid tmc_ramp_set_enabled(void *ramp, TMC_RampType type, bool enabled)\n{\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\tdefault:\n\t\ttmc_ramp_linear_set_enabled((TMC_LinearRamp *)ramp, enabled);\n\t\tbreak;\n\t}\n}\n\nvoid tmc_ramp_toggle_enabled(void *ramp, TMC_RampType type)\n{\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\tdefault:\n\t\ttmc_ramp_linear_set_enabled((TMC_LinearRamp *)ramp, !tmc_ramp_get_enabled(ramp, type));\n\t\tbreak;\n\t}\n}\n\nint32_t tmc_ramp_get_dx(void *ramp, TMC_RampType type)\n{\n\tint32_t dx = 0;\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\tdefault:\n\t\tdx = tmc_ramp_linear_get_dx((TMC_LinearRamp *)ramp);\n\t\tbreak;\n\t}\n\treturn dx;\n}\n\nvoid tmc_ramp_reset_dx(void *ramp, TMC_RampType type)\n{\n\tswitch(type) {\n\tcase TMC_RAMP_TYPE_LINEAR:\n\tdefault:\n\t\ttmc_ramp_linear_reset_dx((TMC_LinearRamp *)ramp);\n\t\tbreak;\n\t}\n}\n",
        "TMC5161.c": "/*\n * TMC5161.c\n *\n *  Created on: 13.06.2017\n *      Author: LK\n */\n\n#include \"TMC5161.h\"\n\n// => SPI wrapper\nextern void tmc5161_readWriteArray(uint8_t channel, uint8_t *data, size_t length);\n// <= SPI wrapper\n\nvoid tmc5161_writeDatagram(uint8_t channel, uint8_t address, uint8_t x1, uint8_t x2, uint8_t x3, uint8_t x4)\n{\n\tuint8_t data[5] = { address | TMC5161_WRITE_BIT, x1, x2, x3, x4 };\n\ttmc5161_readWriteArray(channel, &data[0], 5);\n}\n\nvoid tmc5161_writeInt(uint8_t channel, uint8_t address, int32_t value)\n{\n\ttmc5161_writeDatagram(channel, address, BYTE(value, 3), BYTE(value, 2), BYTE(value, 1), BYTE(value, 0));\n}\n\nint32_t tmc5161_readInt(uint8_t channel, uint8_t address)\n{\n\taddress = TMC_ADDRESS(address);\n\n\tuint8_t data[5];\n\n\tdata[0] = address;\n\ttmc5161_readWriteArray(channel, &data[0], 5);\n\n\tdata[0] = address;\n\ttmc5161_readWriteArray(channel, &data[0], 5);\n\n\treturn _8_32(data[1], data[2], data[3], data[4]);\n}\n\nvoid tmc5161_init(void)\n{\n\n}\n\nvoid tmc5161_rotate(uint8_t channel, int32_t velocity)\n{\n\t// set absolute velocity, independent from direction\n\ttmc5161_writeInt(channel, TMC5161_VMAX, abs(velocity));\n\t// signdedness defines velocity mode direction bit in rampmode register\n\ttmc5161_writeInt(channel, TMC5161_RAMPMODE, (velocity >= 0) ? TMC5161_MODE_VELPOS : TMC5161_MODE_VELNEG);\n}\n\nvoid tmc5161_right(uint8_t channel, uint32_t velocity)\n{\n\treturn tmc5161_rotate(channel, velocity);\n}\n\nvoid tmc5161_left(uint8_t channel, uint32_t velocity)\n{\n\treturn tmc5161_rotate(channel, -velocity);\n}\n\nvoid tmc5161_stop(uint8_t channel)\n{\n\treturn tmc5161_rotate(channel, 0);\n}\n\nvoid tmc5161_moveTo(uint8_t channel, int32_t position, uint32_t velocity)\n{\n\ttmc5161_writeInt(channel, TMC5161_RAMPMODE, TMC5161_MODE_POSITION);\n\ttmc5161_writeInt(channel, TMC5161_VMAX, velocity); // Not written to register while in rampVelocity mode -> write copy when switching\n\ttmc5161_writeInt(channel, TMC5161_XTARGET, position);\n}\n\nvoid tmc5161_moveBy(uint8_t channel, int32_t ticks, uint32_t velocity)\n{\n\t// determine actual position and add numbers of ticks to move\n\tticks += tmc5161_readInt(channel, TMC5161_XACTUAL);\n\n\ttmc5161_moveTo(channel, ticks, velocity);\n}\n",
        "atmo_tmc5161.c": "/******************************************************************************/\n/*                                Includes                                    */\n/******************************************************************************/\n#include \"atmo_tmc5161.h\"\n\n\n/******************************************************************************/\n/*                                 Defines                                    */\n/******************************************************************************/\n#define _ATMO_MAX_TMC5161_INSTANCES\t\t2\n#define _SPI_CS\t\tP_CS\n\n// Scale factors\n#define TMC5161_MAX_VELOCITY\t\t\t\t\t1.5E6\n#define TMC5161_MAX_ACCELERATION\t\t\t2500\n#define TMC5161_MAX_POSITION\t\t\t\t\t51200\n\n/******************************************************************************/\n/*                       Structs, Typedefs, and Enums                         */\n/******************************************************************************/\n\n\n/******************************************************************************/\n/*                            Global Variables                                */\n/******************************************************************************/\nstatic uint8_t currNumInstances = 0;\nstatic ATMO_TMC5161_Config_t _configs[_ATMO_MAX_TMC5161_INSTANCES];\n\n// Either 0x21 or 0x31 will work for the CTRLA value\nconst uint8_t tmc5161_ctrla = 1 << SPI_CLK2X_bp    /* Enable Double Speed: disabled */\n| 0 << SPI_DORD_bp   /* Data Order Setting: disabled */\n| 1 << SPI_ENABLE_bp /* Enable Module: enabled */\n| 1 << SPI_MASTER_bp /* SPI module in master mode */\n| SPI_PRESC_DIV4_gc; /* System Clock / 4 */\n\n// Must use SPI Mode 3\nconst uint8_t tmc5161_ctrlb =  0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */\n| 0 << SPI_BUFWR_bp /* Buffer Write Mode: disabled */\n| 1 << SPI_SSD_bp   /* Slave Select Disable: disabled */\n| SPI_MODE_3_gc;    /* SPI Mode 3 */\n\nstatic uint8_t orig_ctrla, orig_ctrlb;\n\n/******************************************************************************/\n/*                      Private Function Definitions                          */\n/******************************************************************************/\nstatic void _cs_config(ATMO_DriverInstanceHandle_t gpioDriverIntance, ATMO_SPI_CS_t csPin )\n{\n\tATMO_GPIO_Config_t pinConfig;\n\n\t// configure the CS pin\n\tpinConfig.pinMode = ATMO_GPIO_PinMode_Output_PushPull;\n\tpinConfig.initialState = ATMO_GPIO_PinState_High;\n\tATMO_GPIO_SetPinConfiguration(gpioDriverIntance, csPin, &pinConfig );\n}\n\nstatic void _spi_config(void)\n{\n\t/* Call before any SPI transaction to make sure the settings are correct */\n\torig_ctrla = SPI0.CTRLA;\n\torig_ctrlb = SPI0.CTRLB;\n\n\tSPI0.CTRLA = tmc5161_ctrla;\n\tSPI0.CTRLB = tmc5161_ctrlb;\n}\n\nstatic void _spi_restore(void)\n{\n\t/* Call after any SPI transfer to return the original settings */\n\tSPI0.CTRLA = orig_ctrla;\n\tSPI0.CTRLB = orig_ctrlb;\n}\n\nstatic void _spi_exchange(uint8_t channel, uint8_t *data, size_t length)\n{\n\t_spi_config();\n\n\t// assert CS\n\tATMO_GPIO_SetPinState(0, _configs[channel].cs_pin, ATMO_GPIO_PinState_Low);\n\n\t// write command and data\n\tSPI_0_exchange_block(data, length);\n\n\t// deassert CS\n\tATMO_GPIO_SetPinState(0, _configs[channel].cs_pin, ATMO_GPIO_PinState_High);\n\n\t_spi_restore();\n}\n\nstatic void _tmc5161_config(uint8_t channel)\n{\n\t// Example configuration from data sheet\n\ttmc5161_writeInt(channel, TMC5161_DRV_CONF, 0x20002);\n\ttmc5161_writeInt(channel, TMC5161_CHOPCONF, 0x100C3);\n\t//tmc5161_writeInt(channel, TMC5161_IHOLD_IRUN, 0x61F0A);\n\ttmc5161_writeInt(channel, TMC5161_IHOLD_IRUN, 10 << TMC5161_IHOLDDELAY_SHIFT | 31 << TMC5161_IRUN_SHIFT | 1 << TMC5161_IHOLD_SHIFT);\n\ttmc5161_writeInt(channel, TMC5161_TPOWERDOWN, 0x0A);\n\ttmc5161_writeInt(channel, TMC5161_GCONF, 0x04);\n\ttmc5161_writeInt(channel, TMC5161_TPWMTHRS, 0x1F4);\n\n\t/* Current configuration */\n\ttmc5161_writeInt(channel, TMC5161_GLOBAL_SCALER, 60);\t// Global scalar for max motor current at IRUN (1A rms)\n\n\t// Motion parameters\n\ttmc5161_writeInt(channel, TMC5161_A1, 1000);\n\ttmc5161_writeInt(channel, TMC5161_V1, 50000);\n\ttmc5161_writeInt(channel, TMC5161_AMAX, 500);\n\ttmc5161_writeInt(channel, TMC5161_VMAX, 200000);\n\ttmc5161_writeInt(channel, TMC5161_DMAX, 700);\n\ttmc5161_writeInt(channel, TMC5161_D1, 1400);\n\ttmc5161_writeInt(channel, TMC5161_VSTOP, 10);\n\ttmc5161_writeInt(channel, TMC5161_RAMPMODE, 0);\n}\n\n/******************************************************************************/\n/*                       Public Function Definitions                          */\n/******************************************************************************/\n/* This function needs to be defined for the Trinamic API */\nvoid tmc5161_readWriteArray(uint8_t channel, uint8_t *data, size_t length)\n{\n  _spi_exchange(channel, data, length);\n}\n\nATMO_TMC5161_Status_t ATMO_TMC5161_Init(ATMO_DriverInstanceHandle_t *handle, ATMO_TMC5161_Config_t *config)\n{\n\tif(currNumInstances >= _ATMO_MAX_TMC5161_INSTANCES || config == NULL)\n\t{\n\t\treturn ATMO_TMC5161_Status_Fail;\n\t}\n\n\t*handle = currNumInstances;\n\tcurrNumInstances++;\n\n\t// Default value for VMAX\n\tconfig->vmax = 200000;\n\n\tmemcpy(&_configs[*handle], config, sizeof(ATMO_TMC5161_Config_t));\n\n  _cs_config(config->gpioDriverInstance, config->cs_pin);\n\n\t_tmc5161_config(*handle);\n\n  return ATMO_TMC5161_Status_Success;\n}\n\nATMO_TMC5161_Status_t ATMO_TMC5161_SetVelocity(ATMO_DriverInstanceHandle_t handle, uint8_t velocity)\n{\n\t// Scale the input from IoT Studio\n\t// Max value is 2^23 - 512\n\t// uint32_t scaled_velocity = (uint32_t) (((float) velocity / 100.0) * 0x7FFE00);\n\tuint32_t scaled_velocity = (uint32_t) (((float) velocity / 100.0) * TMC5161_MAX_VELOCITY);\n\t_configs[handle].vmax = scaled_velocity;\n\ttmc5161_writeInt(handle, TMC5161_VMAX, scaled_velocity);\n\t// Set V1 to 1/4 of vmax\n\ttmc5161_writeInt(handle, TMC5161_V1, scaled_velocity >> 2);\n\n  return ATMO_TMC5161_Status_Success;\n}\n\nATMO_TMC5161_Status_t ATMO_TMC5161_SetAcceleration(ATMO_DriverInstanceHandle_t handle, uint8_t acceleration)\n{\n\t// Scale the input from IoT Studio\n\t// Max value is 2^16-1\n\tuint16_t scaled_acceleration = (uint16_t) (((float) acceleration / 100.0) * TMC5161_MAX_ACCELERATION);\n\ttmc5161_writeInt(handle, TMC5161_AMAX, scaled_acceleration);\n\t// Set A1 to twice AMAX\n\ttmc5161_writeInt(handle, TMC5161_A1, scaled_acceleration << 1);\n\n  return ATMO_TMC5161_Status_Success;\n}\n\nATMO_TMC5161_Status_t ATMO_TMC5161_MoveTo(ATMO_DriverInstanceHandle_t handle, uint8_t position)\n{\n\t// Scale the input from IoT Studio\n\t// Value range can be treated as unsigned 0 -> 2^32-1\n\t// Scale to be within 1 full rotation of 51200\n\tuint32_t scaled_position = (uint32_t) (((float) position / 100.0) * TMC5161_MAX_POSITION);\n  tmc5161_moveTo(handle, _configs[handle].dir * scaled_position, _configs[handle].vmax);\n\n  return ATMO_TMC5161_Status_Success;\n}\n\nATMO_TMC5161_Status_t ATMO_TMC5161_SetDirection(ATMO_DriverInstanceHandle_t handle, ATMO_BOOL_t direction)\n{\n\tuint32_t mode;\n\n\tif(direction)\n\t{\n\t\tmode = 0x1;\n\t\t_configs[handle].dir = 1;\n\t}\n\telse\n\t{\n\t\tmode = 0x2;\n\t\t_configs[handle].dir = -1;\n\t}\n\n\t// Set VMAX to 0 first so the motor doesn't explode\n\ttmc5161_writeInt(handle, TMC5161_VMAX, 0);\n\n\ttmc5161_writeInt(handle, TMC5161_RAMPMODE, mode);\n\n\treturn ATMO_TMC5161_Status_Success;\n}\n\nATMO_TMC5161_Status_t ATMO_TMC5161_Stop(ATMO_DriverInstanceHandle_t handle)\n{\n  tmc5161_rotate(handle, 0);\n\n  return ATMO_TMC5161_Status_Success;\n}\n"
      }
    }
  },
  "md5": "925d19ba73b532b6447c868002bc11ff"
}